//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use sea_orm::{Database, DbConn, EntityTrait, JoinType, QueryOrder, QuerySelect, QueryTrait};

pub mod prelude;

pub mod appointment;
pub mod event;
pub mod event_role_assignment;
pub mod project;
pub mod project_preference;
pub mod sea_orm_active_enums;
pub mod sidequest;
pub mod sidequest_attempt;
pub mod sidequest_score;
pub mod team;
pub mod team_role_assignment;
pub mod user;

pub use crate::RepositoryResult;

use crate::RepositoryError;
use sea_orm::prelude::*;
use sea_orm::sea_query::SimpleExpr::Column;
use sea_orm::sea_query::{Alias, IntoColumnRef, IntoTableRef, Query};
use sea_orm::sqlx::types::chrono::NaiveDateTime;
pub use sea_orm::DbErr;
use slug::slugify;

#[derive(Clone)]
pub struct DbRepository {
    pub conn: DbConn,
}

impl DbRepository {
    #[must_use]
    pub const fn new(conn: DbConn) -> Self {
        Self { conn }
    }

    pub async fn from_url(url: &str) -> RepositoryResult<Self> {
        let result = Self {
            conn: Database::connect(url).await?,
        };

        Ok(result)
    }

    #[must_use]
    pub const fn conn(&self) -> &DbConn {
        &self.conn
    }

    /// Generates slug based on the name
    /// and checks if it is unique (with respect to the event, if provided).
    pub async fn generate_slug(
        &self,
        name: &str,
        event_id: Option<Uuid>,
        table: impl IntoTableRef,
    ) -> RepositoryResult<String> {
        let slug = slugify(name);

        let builder = self.conn().get_database_backend();
        let slug_col = Alias::new("slug").into_column_ref();

        let mut query = Query::select()
            .column(slug_col.clone())
            .from(table)
            .and_where(Column(slug_col).eq(slug.clone()))
            .to_owned();

        if let Some(event_id) = event_id {
            let event_id_col = Alias::new("event_id").into_column_ref();
            query = query
                .and_where(Column(event_id_col).eq(event_id))
                .to_owned();
        }

        let stmt = builder.build(&query);
        let result = self.conn().execute(stmt).await?;

        if result.rows_affected() != 0 {
            return Err(RepositoryError::SlugNotUnique { slug });
        }

        Ok(slug)
    }

    // region: Event
    pub async fn get_events(&self) -> RepositoryResult<Vec<event::Model>> {
        let events = event::Entity::find()
            .order_by_asc(event::Column::Start)
            .all(self.conn())
            .await?;

        Ok(events)
    }

    pub async fn get_event(&self, event_id: Uuid) -> RepositoryResult<event::Model> {
        let event = event::Entity::find_by_id(event_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Event".to_string(),
                id: event_id.to_string(),
            })?;

        Ok(event)
    }

    pub async fn get_event_by_slug(&self, event_slug: &str) -> RepositoryResult<event::Model> {
        let event = event::Entity::find()
            .filter(event::Column::Slug.eq(event_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Event".to_string(),
                id: event_slug.to_string(),
            })?;

        Ok(event)
    }
    // endregion

    // region: Team
    pub async fn get_teams(&self, event_id: Uuid) -> RepositoryResult<Vec<team::Model>> {
        let teams = team::Entity::find()
            .filter(team::Column::EventId.eq(event_id))
            .order_by_asc(team::Column::Index)
            .order_by_asc(team::Column::Id)
            .all(self.conn())
            .await?;

        Ok(teams)
    }

    pub async fn get_team(&self, team_id: Uuid) -> RepositoryResult<team::Model> {
        let team = team::Entity::find_by_id(team_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Team".to_string(),
                id: team_id.to_string(),
            })?;

        Ok(team)
    }

    pub async fn get_team_by_slug(
        &self,
        event_slug: &str,
        team_slug: &str,
    ) -> RepositoryResult<team::Model> {
        let team = team::Entity::find()
            .inner_join(event::Entity)
            .filter(event::Column::Slug.eq(event_slug))
            .filter(team::Column::Slug.eq(team_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Team".to_string(),
                id: format!("{event_slug}/{team_slug}"),
            })?;

        Ok(team)
    }
    // endregion

    // region: User
    pub async fn get_user(&self, user_id: Uuid) -> RepositoryResult<user::Model> {
        let user = user::Entity::find_by_id(user_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "User".to_string(),
                id: user_id.to_string(),
            })?;

        Ok(user)
    }

    pub async fn get_user_by_auth_id(&self, auth_id: &str) -> RepositoryResult<user::Model> {
        let user = user::Entity::find()
            .filter(user::Column::AuthId.eq(auth_id))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "User".to_string(),
                id: auth_id.to_string(),
            })?;

        Ok(user)
    }
    // endregion

    // region: Role Assignment
    pub async fn get_event_roles(
        &self,
        event_id: Option<Uuid>,
        user_id: Option<Uuid>,
    ) -> RepositoryResult<Vec<event_role_assignment::Model>> {
        let roles = event_role_assignment::Entity::find()
            .apply_if(event_id, |q, v| {
                q.filter(event_role_assignment::Column::EventId.eq(v))
            })
            .apply_if(user_id, |q, v| {
                q.filter(event_role_assignment::Column::UserId.eq(v))
            })
            .all(self.conn())
            .await?;

        Ok(roles)
    }

    pub async fn get_team_roles(
        &self,
        team_id: Option<Uuid>,
        user_id: Option<Uuid>,
    ) -> RepositoryResult<Vec<team_role_assignment::Model>> {
        let roles = team_role_assignment::Entity::find()
            .apply_if(team_id, |q, v| {
                q.filter(team_role_assignment::Column::TeamId.eq(v))
            })
            .apply_if(user_id, |q, v| {
                q.filter(team_role_assignment::Column::UserId.eq(v))
            })
            .all(self.conn())
            .await?;

        Ok(roles)
    }
    // endregion

    // region: Project
    pub async fn get_projects(&self, event_id: Uuid) -> RepositoryResult<Vec<project::Model>> {
        let projects = project::Entity::find()
            .filter(project::Column::EventId.eq(event_id))
            .order_by_asc(project::Column::Name)
            .all(self.conn())
            .await?;

        Ok(projects)
    }

    pub async fn get_project(&self, project_id: Uuid) -> RepositoryResult<project::Model> {
        let project = project::Entity::find_by_id(project_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Project".to_string(),
                id: project_id.to_string(),
            })?;

        Ok(project)
    }

    pub async fn get_project_by_slug(
        &self,
        event_slug: &str,
        project_slug: &str,
    ) -> RepositoryResult<project::Model> {
        let project = project::Entity::find()
            .inner_join(event::Entity)
            .filter(event::Column::Slug.eq(event_slug))
            .filter(project::Column::Slug.eq(project_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Project".to_string(),
                id: format!("{event_slug}/{project_slug}"),
            })?;

        Ok(project)
    }
    // endregion

    // region: Project Preference
    pub async fn get_project_preferences(
        &self,
        team_id: Uuid,
    ) -> RepositoryResult<Vec<project_preference::Model>> {
        let project_preferences = project_preference::Entity::find()
            .filter(project_preference::Column::TeamId.eq(team_id))
            .order_by_asc(project_preference::Column::Score)
            .all(self.conn())
            .await?;

        Ok(project_preferences)
    }
    // endregion

    // region: Sidequest
    pub async fn get_sidequests(&self, event_id: Uuid) -> RepositoryResult<Vec<sidequest::Model>> {
        let sidequests = sidequest::Entity::find()
            .filter(sidequest::Column::EventId.eq(event_id))
            .order_by_asc(sidequest::Column::Name)
            .all(self.conn())
            .await?;

        Ok(sidequests)
    }

    pub async fn get_sidequest(&self, sidequest_id: Uuid) -> RepositoryResult<sidequest::Model> {
        let sidequest = sidequest::Entity::find_by_id(sidequest_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Sidequest".to_string(),
                id: sidequest_id.to_string(),
            })?;

        Ok(sidequest)
    }

    pub async fn get_sidequest_by_slug(
        &self,
        event_slug: &str,
        sidequest_slug: &str,
    ) -> RepositoryResult<sidequest::Model> {
        let sidequest = sidequest::Entity::find()
            .inner_join(event::Entity)
            .filter(event::Column::Slug.eq(event_slug))
            .filter(sidequest::Column::Slug.eq(sidequest_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Sidequest".to_string(),
                id: format!("{event_slug}/{sidequest_slug}"),
            })?;

        Ok(sidequest)
    }
    // endregion

    // region: Sidequest Attempt
    fn get_sidequest_attempts_base_query(
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> Select<sidequest_attempt::Entity> {
        sidequest_attempt::Entity::find()
            .apply_if(after, |q, v| {
                q.filter(sidequest_attempt::Column::AttemptedAt.gte(v))
            })
            .apply_if(before, |q, v| {
                q.filter(sidequest_attempt::Column::AttemptedAt.lte(v))
            })
            .order_by_asc(sidequest_attempt::Column::AttemptedAt)
    }

    pub async fn get_sidequest_attempts(
        &self,
        event_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .join(
                JoinType::InnerJoin,
                sidequest_attempt::Relation::Sidequest.def(),
            )
            .filter(sidequest::Column::EventId.eq(event_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_sidequest_attempts_by_sidequest(
        &self,
        sidequest_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .filter(sidequest_attempt::Column::SidequestId.eq(sidequest_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_sidequest_attempts_by_team(
        &self,
        team_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .join(JoinType::InnerJoin, sidequest_attempt::Relation::User.def())
            .join(
                JoinType::InnerJoin,
                user::Relation::TeamRoleAssignment.def(),
            )
            .filter(team_role_assignment::Column::TeamId.eq(team_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_sidequest_attempts_by_user(
        &self,
        user_id: Uuid,
        event_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .join(
                JoinType::InnerJoin,
                sidequest_attempt::Relation::Sidequest.def(),
            )
            .filter(sidequest_attempt::Column::UserId.eq(user_id))
            .filter(sidequest::Column::EventId.eq(event_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_latest_sidequest_attempt_by_user(
        &self,
        user_id: Uuid,
        event_id: Uuid,
    ) -> RepositoryResult<Option<sidequest_attempt::Model>> {
        let attempt = sidequest_attempt::Entity::find()
            .join(
                JoinType::InnerJoin,
                sidequest_attempt::Relation::Sidequest.def(),
            )
            .filter(sidequest_attempt::Column::UserId.eq(user_id))
            .filter(sidequest::Column::EventId.eq(event_id))
            .order_by_desc(sidequest_attempt::Column::AttemptedAt)
            .one(self.conn())
            .await?;

        Ok(attempt)
    }

    pub async fn get_sidequest_attempt(
        &self,
        attempt_id: Uuid,
    ) -> RepositoryResult<sidequest_attempt::Model> {
        let attempt = sidequest_attempt::Entity::find_by_id(attempt_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Sidequest Attempt".to_string(),
                id: attempt_id.to_string(),
            })?;

        Ok(attempt)
    }
    // endregion

    // region: Appointment
    pub async fn get_appointments(
        &self,
        event_id: Uuid,
    ) -> RepositoryResult<Vec<appointment::Model>> {
        let appointments = appointment::Entity::find()
            .filter(appointment::Column::EventId.eq(event_id))
            .order_by_asc(appointment::Column::Start)
            .all(self.conn())
            .await?;

        Ok(appointments)
    }

    pub async fn get_appointment(
        &self,
        appointment_id: Uuid,
    ) -> RepositoryResult<appointment::Model> {
        let appointment = appointment::Entity::find()
            .filter(appointment::Column::Id.eq(appointment_id))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Appointment".to_string(),
                id: appointment_id.to_string(),
            })?;

        Ok(appointment)
    }
    // endregion
}
