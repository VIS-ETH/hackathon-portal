//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.16

use sea_orm::{Database, DbConn, EntityTrait, JoinType, QueryOrder, QuerySelect, QueryTrait};
use std::time::Duration;

pub mod prelude;

pub mod appointment;
pub mod event;
pub mod event_role_assignment;
pub mod event_user_discord_id;
pub mod expert_rating;
pub mod project;
pub mod project_preference;
pub mod sea_orm_active_enums;
pub mod sidequest;
pub mod sidequest_attempt;
pub mod sidequest_score;
pub mod team;
pub mod team_role_assignment;
pub mod upload;
pub mod user;

pub use crate::RepositoryResult;

use crate::db::prelude::db_event_user_discord_id;
use crate::RepositoryError;
use sea_orm::prelude::*;
use sea_orm::sea_query::SimpleExpr::Column;
use sea_orm::sea_query::{Alias, IntoColumnRef, IntoTableRef, Query};
use sea_orm::sqlx::types::chrono::NaiveDateTime;
pub use sea_orm::DbErr;
use serde::{Deserialize, Serialize};
use slug::slugify;
use tokio::time::timeout;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct DbConfig {
    pub url: String,
}

#[derive(Clone)]
pub struct DbRepository {
    pub conn: DbConn,
}

impl DbRepository {
    #[must_use]
    pub const fn new(conn: DbConn) -> Self {
        Self { conn }
    }

    pub async fn from_config(config: &DbConfig) -> RepositoryResult<Self> {
        let result = Self {
            conn: Database::connect(config.url.clone()).await?,
        };

        Ok(result)
    }

    #[must_use]
    pub const fn conn(&self) -> &DbConn {
        &self.conn
    }

    pub async fn ping(&self, timeout_duration: Duration) -> RepositoryResult<()> {
        match timeout(timeout_duration, self.conn().ping()).await {
            Ok(inner) => inner.map_err(Into::into),
            Err(_) => Err(RepositoryError::Timeout {
                message: "Database ping timed out".to_string(),
            }),
        }
    }

    /// Generates slug based on the name
    /// and checks if it is unique (with respect to the event, if provided).
    pub async fn generate_slug(
        &self,
        name: &str,
        event_id: Option<Uuid>,
        table: impl IntoTableRef,
    ) -> RepositoryResult<String> {
        let slug = slugify(name);

        let builder = self.conn().get_database_backend();
        let slug_col = Alias::new("slug").into_column_ref();

        let mut query = Query::select();
        let mut query_ref = query
            .column(slug_col.clone())
            .from(table)
            .and_where(Column(slug_col).eq(slug.clone()));

        if let Some(event_id) = event_id {
            let event_id_col = Alias::new("event_id").into_column_ref();
            query_ref = query_ref.and_where(Column(event_id_col).eq(event_id));
        }

        let stmt = builder.build(query_ref);
        let result = self.conn().execute(stmt).await?;

        if result.rows_affected() != 0 {
            return Err(RepositoryError::SlugNotUnique { slug });
        }

        Ok(slug)
    }

    // region: Event
    pub async fn get_events(&self) -> RepositoryResult<Vec<event::Model>> {
        let events = event::Entity::find()
            .order_by_desc(event::Column::Start)
            .all(self.conn())
            .await?;

        Ok(events)
    }

    pub async fn get_event(&self, event_id: Uuid) -> RepositoryResult<event::Model> {
        let event = event::Entity::find_by_id(event_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Event".to_string(),
                id: event_id.to_string(),
            })?;

        Ok(event)
    }

    pub async fn get_event_by_slug(&self, event_slug: &str) -> RepositoryResult<event::Model> {
        let event = event::Entity::find()
            .filter(event::Column::Slug.eq(event_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Event".to_string(),
                id: event_slug.to_string(),
            })?;

        Ok(event)
    }
    // endregion

    // region: Team
    pub async fn get_teams(&self, event_id: Uuid) -> RepositoryResult<Vec<team::Model>> {
        let teams = team::Entity::find()
            .filter(team::Column::EventId.eq(event_id))
            .order_by_asc(team::Column::Index)
            .order_by_asc(team::Column::Id)
            .all(self.conn())
            .await?;

        Ok(teams)
    }

    pub async fn get_team(&self, team_id: Uuid) -> RepositoryResult<team::Model> {
        let team = team::Entity::find_by_id(team_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Team".to_string(),
                id: team_id.to_string(),
            })?;

        Ok(team)
    }

    pub async fn get_team_by_slug(
        &self,
        event_slug: &str,
        team_slug: &str,
    ) -> RepositoryResult<team::Model> {
        let team = team::Entity::find()
            .inner_join(event::Entity)
            .filter(event::Column::Slug.eq(event_slug))
            .filter(team::Column::Slug.eq(team_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Team".to_string(),
                id: format!("{event_slug}/{team_slug}"),
            })?;

        Ok(team)
    }
    // endregion

    // region: Expert Rating
    pub async fn get_expert_ratings(
        &self,
        team_id: Uuid,
    ) -> RepositoryResult<Vec<expert_rating::Model>> {
        let expert_ratings = expert_rating::Entity::find()
            .filter(expert_rating::Column::TeamId.eq(team_id))
            .order_by_asc(expert_rating::Column::Id)
            .all(self.conn())
            .await?;

        Ok(expert_ratings)
    }

    pub async fn get_expert_rating(
        &self,
        expert_rating_id: Uuid,
    ) -> RepositoryResult<expert_rating::Model> {
        let expert_rating = expert_rating::Entity::find_by_id(expert_rating_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Expert Rating".to_string(),
                id: expert_rating_id.to_string(),
            })?;

        Ok(expert_rating)
    }
    // endregion

    // region: User
    pub async fn get_user(&self, user_id: Uuid) -> RepositoryResult<user::Model> {
        self.get_user_txn(user_id, self.conn()).await
    }

    pub async fn get_user_txn<C: ConnectionTrait>(
        &self,
        user_id: Uuid,
        txn: &C,
    ) -> RepositoryResult<user::Model> {
        let user = user::Entity::find_by_id(user_id)
            .one(txn)
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "User".to_string(),
                id: user_id.to_string(),
            })?;

        Ok(user)
    }

    pub async fn get_user_by_auth_id(&self, auth_id: &str) -> RepositoryResult<user::Model> {
        let user = user::Entity::find()
            .filter(user::Column::AuthId.eq(auth_id))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "User".to_string(),
                id: auth_id.to_string(),
            })?;

        Ok(user)
    }
    // endregion

    // region: Role Assignment
    pub async fn get_event_roles(
        &self,
        event_id: Option<Uuid>,
        user_id: Option<Uuid>,
    ) -> RepositoryResult<Vec<event_role_assignment::Model>> {
        let roles = event_role_assignment::Entity::find()
            .apply_if(event_id, |q, v| {
                q.filter(event_role_assignment::Column::EventId.eq(v))
            })
            .apply_if(user_id, |q, v| {
                q.filter(event_role_assignment::Column::UserId.eq(v))
            })
            .all(self.conn())
            .await?;

        Ok(roles)
    }

    pub async fn get_team_roles(
        &self,
        team_id: Option<Uuid>,
        user_id: Option<Uuid>,
    ) -> RepositoryResult<Vec<team_role_assignment::Model>> {
        let roles = team_role_assignment::Entity::find()
            .apply_if(team_id, |q, v| {
                q.filter(team_role_assignment::Column::TeamId.eq(v))
            })
            .apply_if(user_id, |q, v| {
                q.filter(team_role_assignment::Column::UserId.eq(v))
            })
            .all(self.conn())
            .await?;

        Ok(roles)
    }
    // endregion

    // region: Project
    pub async fn get_projects(&self, event_id: Uuid) -> RepositoryResult<Vec<project::Model>> {
        let projects = project::Entity::find()
            .filter(project::Column::EventId.eq(event_id))
            .order_by_asc(project::Column::Name)
            .all(self.conn())
            .await?;

        Ok(projects)
    }

    pub async fn get_project(&self, project_id: Uuid) -> RepositoryResult<project::Model> {
        let project = project::Entity::find_by_id(project_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Project".to_string(),
                id: project_id.to_string(),
            })?;

        Ok(project)
    }

    pub async fn get_project_by_slug(
        &self,
        event_slug: &str,
        project_slug: &str,
    ) -> RepositoryResult<project::Model> {
        let project = project::Entity::find()
            .inner_join(event::Entity)
            .filter(event::Column::Slug.eq(event_slug))
            .filter(project::Column::Slug.eq(project_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Project".to_string(),
                id: format!("{event_slug}/{project_slug}"),
            })?;

        Ok(project)
    }
    // endregion

    // region: Project Preference
    pub async fn get_project_preferences(
        &self,
        team_id: Uuid,
    ) -> RepositoryResult<Vec<project_preference::Model>> {
        let project_preferences = project_preference::Entity::find()
            .filter(project_preference::Column::TeamId.eq(team_id))
            .order_by_asc(project_preference::Column::Score)
            .all(self.conn())
            .await?;

        Ok(project_preferences)
    }
    // endregion

    // region: Sidequest
    pub async fn get_sidequests(&self, event_id: Uuid) -> RepositoryResult<Vec<sidequest::Model>> {
        let sidequests = sidequest::Entity::find()
            .filter(sidequest::Column::EventId.eq(event_id))
            .order_by_asc(sidequest::Column::Name)
            .all(self.conn())
            .await?;

        Ok(sidequests)
    }

    pub async fn get_sidequest(&self, sidequest_id: Uuid) -> RepositoryResult<sidequest::Model> {
        let sidequest = sidequest::Entity::find_by_id(sidequest_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Sidequest".to_string(),
                id: sidequest_id.to_string(),
            })?;

        Ok(sidequest)
    }

    pub async fn get_sidequest_by_slug(
        &self,
        event_slug: &str,
        sidequest_slug: &str,
    ) -> RepositoryResult<sidequest::Model> {
        let sidequest = sidequest::Entity::find()
            .inner_join(event::Entity)
            .filter(event::Column::Slug.eq(event_slug))
            .filter(sidequest::Column::Slug.eq(sidequest_slug))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Sidequest".to_string(),
                id: format!("{event_slug}/{sidequest_slug}"),
            })?;

        Ok(sidequest)
    }
    // endregion

    // region: Sidequest Attempt
    fn get_sidequest_attempts_base_query(
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> Select<sidequest_attempt::Entity> {
        sidequest_attempt::Entity::find()
            .apply_if(after, |q, v| {
                q.filter(sidequest_attempt::Column::AttemptedAt.gte(v))
            })
            .apply_if(before, |q, v| {
                q.filter(sidequest_attempt::Column::AttemptedAt.lte(v))
            })
            .order_by_desc(sidequest_attempt::Column::AttemptedAt)
    }

    pub async fn get_sidequest_attempts(
        &self,
        event_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .join(
                JoinType::InnerJoin,
                sidequest_attempt::Relation::Sidequest.def(),
            )
            .filter(sidequest::Column::EventId.eq(event_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_sidequest_attempts_by_sidequest(
        &self,
        sidequest_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .filter(sidequest_attempt::Column::SidequestId.eq(sidequest_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_sidequest_attempts_by_team(
        &self,
        team_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .join(JoinType::InnerJoin, sidequest_attempt::Relation::User.def())
            .join(
                JoinType::InnerJoin,
                user::Relation::TeamRoleAssignment.def(),
            )
            .filter(team_role_assignment::Column::TeamId.eq(team_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_sidequest_attempts_by_user(
        &self,
        user_id: Uuid,
        event_id: Uuid,
        after: Option<NaiveDateTime>,
        before: Option<NaiveDateTime>,
    ) -> RepositoryResult<Vec<sidequest_attempt::Model>> {
        let sidequest_attempts = Self::get_sidequest_attempts_base_query(after, before)
            .join(
                JoinType::InnerJoin,
                sidequest_attempt::Relation::Sidequest.def(),
            )
            .filter(sidequest_attempt::Column::UserId.eq(user_id))
            .filter(sidequest::Column::EventId.eq(event_id))
            .all(self.conn())
            .await?;

        Ok(sidequest_attempts)
    }

    pub async fn get_latest_sidequest_attempt_by_user(
        &self,
        user_id: Uuid,
        event_id: Uuid,
    ) -> RepositoryResult<Option<sidequest_attempt::Model>> {
        let attempt = sidequest_attempt::Entity::find()
            .join(
                JoinType::InnerJoin,
                sidequest_attempt::Relation::Sidequest.def(),
            )
            .filter(sidequest_attempt::Column::UserId.eq(user_id))
            .filter(sidequest::Column::EventId.eq(event_id))
            .order_by_desc(sidequest_attempt::Column::AttemptedAt)
            .one(self.conn())
            .await?;

        Ok(attempt)
    }

    pub async fn get_sidequest_attempt(
        &self,
        attempt_id: Uuid,
    ) -> RepositoryResult<sidequest_attempt::Model> {
        let attempt = sidequest_attempt::Entity::find_by_id(attempt_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Sidequest Attempt".to_string(),
                id: attempt_id.to_string(),
            })?;

        Ok(attempt)
    }
    // endregion

    // region: Appointment
    pub async fn get_appointments(
        &self,
        event_id: Uuid,
    ) -> RepositoryResult<Vec<appointment::Model>> {
        let appointments = appointment::Entity::find()
            .filter(appointment::Column::EventId.eq(event_id))
            .order_by_asc(appointment::Column::Start)
            .all(self.conn())
            .await?;

        Ok(appointments)
    }

    pub async fn get_appointment(
        &self,
        appointment_id: Uuid,
    ) -> RepositoryResult<appointment::Model> {
        let appointment = appointment::Entity::find()
            .filter(appointment::Column::Id.eq(appointment_id))
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Appointment".to_string(),
                id: appointment_id.to_string(),
            })?;

        Ok(appointment)
    }
    // endregion

    // region: Upload
    pub async fn get_upload(&self, upload_id: Uuid) -> RepositoryResult<upload::Model> {
        let upload = upload::Entity::find_by_id(upload_id)
            .one(self.conn())
            .await?
            .ok_or_else(|| RepositoryError::ResourceNotFound {
                resource: "Upload".to_string(),
                id: upload_id.to_string(),
            })?;

        Ok(upload)
    }

    pub async fn get_pending_uploads(&self) -> RepositoryResult<Vec<upload::Model>> {
        let uploads = upload::Entity::find()
            .filter(upload::Column::ValidatedAt.is_null())
            .order_by_asc(upload::Column::RequestedAt)
            .all(self.conn())
            .await?;

        Ok(uploads)
    }
    // endregion

    // region: EventUserDiscordId
    pub async fn get_event_user_discord_id(
        &self,
        event_id: Uuid,
        user_id: Uuid,
    ) -> RepositoryResult<Option<db_event_user_discord_id::Model>> {
        let entry = db_event_user_discord_id::Entity::find()
            .filter(db_event_user_discord_id::Column::UserId.eq(user_id))
            .filter(db_event_user_discord_id::Column::EventId.eq(event_id))
            .one(self.conn())
            .await?;

        Ok(entry)
    }
    // endregion
}
