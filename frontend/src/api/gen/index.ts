/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * hackathon-portal-api
 * OpenAPI spec version: 1.0.0
 */
import { customInstance } from "../client";
import type {
  AffectedRows,
  Appointment,
  AppointmentForCreate,
  AppointmentForUpdate,
  Attempt,
  AttemptForCreate,
  AttemptForUpdate,
  Cooldown,
  CreateUploadDTO,
  DeleteEventRolesBody,
  DeleteSidequest200,
  DeleteSidequestAttempt200,
  DeleteTeamRolesBody,
  DiscordOauthBody,
  Event,
  EventAffiliate,
  EventDiscordResponse,
  EventForUpdate,
  EventRole,
  ExpertRating,
  ExpertRatingForCreate,
  ExpertRatingForUpdate,
  ExpertRatingLeaderboardEntry,
  GetAppointmentsParams,
  GetEventAffiliatesParams,
  GetEventsRoles200,
  GetExpertRatingsParams,
  GetMyPoliciesParams,
  GetProjectsMatching200,
  GetProjectsParams,
  GetSidequestAttemptCooldownParams,
  GetSidequestAttemptsParams,
  GetSidequestsHistory200,
  GetSidequestsHistoryParams,
  GetSidequestsParams,
  GetSidequestsTeamLeaderboardParams,
  GetSidequestsUserLeaderboardParams,
  GetTeamAffiliatesParams,
  GetTeamExpertRatings200,
  GetTeamsInternalParams,
  GetTeamsParams,
  GetTeamsRoles200,
  GetTeamsRolesParams,
  InviteUsersDTO,
  Policies,
  PostEventDiscordOauth200,
  Project,
  ProjectForCreate,
  ProjectForUpdate,
  ProjectIdDTO,
  PublicError,
  PutEventRolesBody,
  PutTeamRolesBody,
  ReducedUser,
  Sidequest,
  SidequestForCreate,
  SidequestForUpdate,
  Team,
  TeamAffiliate,
  TeamCredentials,
  TeamForCreate,
  TeamForUpdate,
  TeamForUpdateInternal,
  TeamInternal,
  TeamLeaderboardEntry,
  TeamRole,
  UploadUrl,
  User,
  UserForUpdate,
  UserLeaderboardEntry,
} from "./schemas";

import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getAppointments = (
  params: GetAppointmentsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Appointment[]>(
    { url: `/api/appointments`, method: "GET", params, signal },
    options,
  );
};

export const getGetAppointmentsQueryKey = (params: GetAppointmentsParams) => {
  return [`/api/appointments`, ...(params ? [params] : [])] as const;
};

export const getGetAppointmentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAppointments>>,
  TError = PublicError,
>(
  params: GetAppointmentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppointments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAppointmentsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppointments>>> = ({
    signal,
  }) => getAppointments(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAppointments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAppointmentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppointments>>
>;
export type GetAppointmentsQueryError = PublicError;

export function useGetAppointments<
  TData = Awaited<ReturnType<typeof getAppointments>>,
  TError = PublicError,
>(
  params: GetAppointmentsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppointments>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointments>>,
          TError,
          Awaited<ReturnType<typeof getAppointments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppointments<
  TData = Awaited<ReturnType<typeof getAppointments>>,
  TError = PublicError,
>(
  params: GetAppointmentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppointments>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointments>>,
          TError,
          Awaited<ReturnType<typeof getAppointments>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppointments<
  TData = Awaited<ReturnType<typeof getAppointments>>,
  TError = PublicError,
>(
  params: GetAppointmentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppointments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAppointments<
  TData = Awaited<ReturnType<typeof getAppointments>>,
  TError = PublicError,
>(
  params: GetAppointmentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAppointments>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAppointmentsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createAppointment = (
  appointmentForCreate: AppointmentForCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Appointment>(
    {
      url: `/api/appointments`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: appointmentForCreate,
      signal,
    },
    options,
  );
};

export const getCreateAppointmentMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAppointment>>,
    TError,
    { data: AppointmentForCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAppointment>>,
  TError,
  { data: AppointmentForCreate },
  TContext
> => {
  const mutationKey = ["createAppointment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAppointment>>,
    { data: AppointmentForCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createAppointment(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAppointment>>
>;
export type CreateAppointmentMutationBody = AppointmentForCreate;
export type CreateAppointmentMutationError = PublicError;

export const useCreateAppointment = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAppointment>>,
      TError,
      { data: AppointmentForCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createAppointment>>,
  TError,
  { data: AppointmentForCreate },
  TContext
> => {
  const mutationOptions = getCreateAppointmentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAppointment = (
  appointmentId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Appointment>(
    { url: `/api/appointments/${appointmentId}`, method: "GET", signal },
    options,
  );
};

export const getGetAppointmentQueryKey = (appointmentId: string) => {
  return [`/api/appointments/${appointmentId}`] as const;
};

export const getGetAppointmentQueryOptions = <
  TData = Awaited<ReturnType<typeof getAppointment>>,
  TError = PublicError,
>(
  appointmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAppointmentQueryKey(appointmentId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppointment>>> = ({
    signal,
  }) => getAppointment(appointmentId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!appointmentId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAppointment>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAppointmentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppointment>>
>;
export type GetAppointmentQueryError = PublicError;

export function useGetAppointment<
  TData = Awaited<ReturnType<typeof getAppointment>>,
  TError = PublicError,
>(
  appointmentId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointment>>,
          TError,
          Awaited<ReturnType<typeof getAppointment>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppointment<
  TData = Awaited<ReturnType<typeof getAppointment>>,
  TError = PublicError,
>(
  appointmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppointment>>,
          TError,
          Awaited<ReturnType<typeof getAppointment>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppointment<
  TData = Awaited<ReturnType<typeof getAppointment>>,
  TError = PublicError,
>(
  appointmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAppointment<
  TData = Awaited<ReturnType<typeof getAppointment>>,
  TError = PublicError,
>(
  appointmentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppointment>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAppointmentQueryOptions(appointmentId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const deleteAppointment = (
  appointmentId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Appointment>(
    { url: `/api/appointments/${appointmentId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteAppointmentMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAppointment>>,
    TError,
    { appointmentId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAppointment>>,
  TError,
  { appointmentId: string },
  TContext
> => {
  const mutationKey = ["deleteAppointment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAppointment>>,
    { appointmentId: string }
  > = (props) => {
    const { appointmentId } = props ?? {};

    return deleteAppointment(appointmentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAppointment>>
>;

export type DeleteAppointmentMutationError = PublicError;

export const useDeleteAppointment = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAppointment>>,
      TError,
      { appointmentId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAppointment>>,
  TError,
  { appointmentId: string },
  TContext
> => {
  const mutationOptions = getDeleteAppointmentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateAppointment = (
  appointmentId: string,
  appointmentForUpdate: AppointmentForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Appointment>(
    {
      url: `/api/appointments/${appointmentId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: appointmentForUpdate,
    },
    options,
  );
};

export const getUpdateAppointmentMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAppointment>>,
    TError,
    { appointmentId: string; data: AppointmentForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentForUpdate },
  TContext
> => {
  const mutationKey = ["updateAppointment"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAppointment>>,
    { appointmentId: string; data: AppointmentForUpdate }
  > = (props) => {
    const { appointmentId, data } = props ?? {};

    return updateAppointment(appointmentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAppointmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAppointment>>
>;
export type UpdateAppointmentMutationBody = AppointmentForUpdate;
export type UpdateAppointmentMutationError = PublicError;

export const useUpdateAppointment = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAppointment>>,
      TError,
      { appointmentId: string; data: AppointmentForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateAppointment>>,
  TError,
  { appointmentId: string; data: AppointmentForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateAppointmentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getEvents = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event[]>(
    { url: `/api/events`, method: "GET", signal },
    options,
  );
};

export const getGetEventsQueryKey = () => {
  return [`/api/events`] as const;
};

export const getGetEventsQueryOptions = <
  TData = Awaited<ReturnType<typeof getEvents>>,
  TError = PublicError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEventsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvents>>> = ({
    signal,
  }) => getEvents(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEvents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEventsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEvents>>
>;
export type GetEventsQueryError = PublicError;

export function useGetEvents<
  TData = Awaited<ReturnType<typeof getEvents>>,
  TError = PublicError,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvents>>,
          TError,
          Awaited<ReturnType<typeof getEvents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEvents<
  TData = Awaited<ReturnType<typeof getEvents>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvents>>,
          TError,
          Awaited<ReturnType<typeof getEvents>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEvents<
  TData = Awaited<ReturnType<typeof getEvents>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetEvents<
  TData = Awaited<ReturnType<typeof getEvents>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvents>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEventsRoles = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetEventsRoles200>(
    { url: `/api/events/roles`, method: "GET", signal },
    options,
  );
};

export const getGetEventsRolesQueryKey = () => {
  return [`/api/events/roles`] as const;
};

export const getGetEventsRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventsRoles>>,
  TError = PublicError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getEventsRoles>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEventsRolesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventsRoles>>> = ({
    signal,
  }) => getEventsRoles(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventsRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEventsRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventsRoles>>
>;
export type GetEventsRolesQueryError = PublicError;

export function useGetEventsRoles<
  TData = Awaited<ReturnType<typeof getEventsRoles>>,
  TError = PublicError,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventsRoles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsRoles>>,
          TError,
          Awaited<ReturnType<typeof getEventsRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventsRoles<
  TData = Awaited<ReturnType<typeof getEventsRoles>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventsRoles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventsRoles>>,
          TError,
          Awaited<ReturnType<typeof getEventsRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventsRoles<
  TData = Awaited<ReturnType<typeof getEventsRoles>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventsRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetEventsRoles<
  TData = Awaited<ReturnType<typeof getEventsRoles>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventsRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventsRolesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEventBySlug = (
  eventSlug: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event>(
    { url: `/api/events/slug/${eventSlug}`, method: "GET", signal },
    options,
  );
};

export const getGetEventBySlugQueryKey = (eventSlug: string) => {
  return [`/api/events/slug/${eventSlug}`] as const;
};

export const getGetEventBySlugQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventBySlug>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetEventBySlugQueryKey(eventSlug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventBySlug>>> = ({
    signal,
  }) => getEventBySlug(eventSlug, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventSlug,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventBySlug>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEventBySlugQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventBySlug>>
>;
export type GetEventBySlugQueryError = PublicError;

export function useGetEventBySlug<
  TData = Awaited<ReturnType<typeof getEventBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventBySlug>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventBySlug>>,
          TError,
          Awaited<ReturnType<typeof getEventBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventBySlug<
  TData = Awaited<ReturnType<typeof getEventBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventBySlug>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventBySlug>>,
          TError,
          Awaited<ReturnType<typeof getEventBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventBySlug<
  TData = Awaited<ReturnType<typeof getEventBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventBySlug>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetEventBySlug<
  TData = Awaited<ReturnType<typeof getEventBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventBySlug>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventBySlugQueryOptions(eventSlug, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEvent = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event>(
    { url: `/api/events/${eventId}`, method: "GET", signal },
    options,
  );
};

export const getGetEventQueryKey = (eventId: string) => {
  return [`/api/events/${eventId}`] as const;
};

export const getGetEventQueryOptions = <
  TData = Awaited<ReturnType<typeof getEvent>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEventQueryKey(eventId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvent>>> = ({
    signal,
  }) => getEvent(eventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetEventQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEvent>>
>;
export type GetEventQueryError = PublicError;

export function useGetEvent<
  TData = Awaited<ReturnType<typeof getEvent>>,
  TError = PublicError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvent>>,
          TError,
          Awaited<ReturnType<typeof getEvent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEvent<
  TData = Awaited<ReturnType<typeof getEvent>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvent>>,
          TError,
          Awaited<ReturnType<typeof getEvent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEvent<
  TData = Awaited<ReturnType<typeof getEvent>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetEvent<
  TData = Awaited<ReturnType<typeof getEvent>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventQueryOptions(eventId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateEvent = (
  eventId: string,
  eventForUpdate: EventForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Event>(
    {
      url: `/api/events/${eventId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: eventForUpdate,
    },
    options,
  );
};

export const getUpdateEventMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEvent>>,
    TError,
    { eventId: string; data: EventForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateEvent>>,
  TError,
  { eventId: string; data: EventForUpdate },
  TContext
> => {
  const mutationKey = ["updateEvent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEvent>>,
    { eventId: string; data: EventForUpdate }
  > = (props) => {
    const { eventId, data } = props ?? {};

    return updateEvent(eventId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEvent>>
>;
export type UpdateEventMutationBody = EventForUpdate;
export type UpdateEventMutationError = PublicError;

export const useUpdateEvent = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateEvent>>,
      TError,
      { eventId: string; data: EventForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateEvent>>,
  TError,
  { eventId: string; data: EventForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getEventAffiliates = (
  eventId: string,
  params?: GetEventAffiliatesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EventAffiliate[]>(
    { url: `/api/events/${eventId}/affiliates`, method: "GET", params, signal },
    options,
  );
};

export const getGetEventAffiliatesQueryKey = (
  eventId: string,
  params?: GetEventAffiliatesParams,
) => {
  return [
    `/api/events/${eventId}/affiliates`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetEventAffiliatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventAffiliates>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetEventAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAffiliates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetEventAffiliatesQueryKey(eventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEventAffiliates>>
  > = ({ signal }) =>
    getEventAffiliates(eventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventAffiliates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEventAffiliatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventAffiliates>>
>;
export type GetEventAffiliatesQueryError = PublicError;

export function useGetEventAffiliates<
  TData = Awaited<ReturnType<typeof getEventAffiliates>>,
  TError = PublicError,
>(
  eventId: string,
  params: undefined | GetEventAffiliatesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAffiliates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventAffiliates>>,
          TError,
          Awaited<ReturnType<typeof getEventAffiliates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventAffiliates<
  TData = Awaited<ReturnType<typeof getEventAffiliates>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetEventAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAffiliates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventAffiliates>>,
          TError,
          Awaited<ReturnType<typeof getEventAffiliates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventAffiliates<
  TData = Awaited<ReturnType<typeof getEventAffiliates>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetEventAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAffiliates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetEventAffiliates<
  TData = Awaited<ReturnType<typeof getEventAffiliates>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetEventAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventAffiliates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventAffiliatesQueryOptions(
    eventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEventDiscordOauth = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EventDiscordResponse>(
    { url: `/api/events/${eventId}/discord`, method: "GET", signal },
    options,
  );
};

export const getGetEventDiscordOauthQueryKey = (eventId: string) => {
  return [`/api/events/${eventId}/discord`] as const;
};

export const getGetEventDiscordOauthQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventDiscordOauth>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDiscordOauth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetEventDiscordOauthQueryKey(eventId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEventDiscordOauth>>
  > = ({ signal }) => getEventDiscordOauth(eventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventDiscordOauth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEventDiscordOauthQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventDiscordOauth>>
>;
export type GetEventDiscordOauthQueryError = PublicError;

export function useGetEventDiscordOauth<
  TData = Awaited<ReturnType<typeof getEventDiscordOauth>>,
  TError = PublicError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDiscordOauth>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventDiscordOauth>>,
          TError,
          Awaited<ReturnType<typeof getEventDiscordOauth>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventDiscordOauth<
  TData = Awaited<ReturnType<typeof getEventDiscordOauth>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDiscordOauth>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventDiscordOauth>>,
          TError,
          Awaited<ReturnType<typeof getEventDiscordOauth>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventDiscordOauth<
  TData = Awaited<ReturnType<typeof getEventDiscordOauth>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDiscordOauth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetEventDiscordOauth<
  TData = Awaited<ReturnType<typeof getEventDiscordOauth>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEventDiscordOauth>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventDiscordOauthQueryOptions(eventId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const postEventDiscordOauth = (
  eventId: string,
  discordOauthBody: DiscordOauthBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PostEventDiscordOauth200>(
    {
      url: `/api/events/${eventId}/discord`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: discordOauthBody,
      signal,
    },
    options,
  );
};

export const getPostEventDiscordOauthMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postEventDiscordOauth>>,
    TError,
    { eventId: string; data: DiscordOauthBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postEventDiscordOauth>>,
  TError,
  { eventId: string; data: DiscordOauthBody },
  TContext
> => {
  const mutationKey = ["postEventDiscordOauth"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postEventDiscordOauth>>,
    { eventId: string; data: DiscordOauthBody }
  > = (props) => {
    const { eventId, data } = props ?? {};

    return postEventDiscordOauth(eventId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostEventDiscordOauthMutationResult = NonNullable<
  Awaited<ReturnType<typeof postEventDiscordOauth>>
>;
export type PostEventDiscordOauthMutationBody = DiscordOauthBody;
export type PostEventDiscordOauthMutationError = PublicError;

export const usePostEventDiscordOauth = <
  TError = PublicError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postEventDiscordOauth>>,
      TError,
      { eventId: string; data: DiscordOauthBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postEventDiscordOauth>>,
  TError,
  { eventId: string; data: DiscordOauthBody },
  TContext
> => {
  const mutationOptions = getPostEventDiscordOauthMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getExpertRatingsLeaderboard = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExpertRatingLeaderboardEntry[]>(
    {
      url: `/api/events/${eventId}/expert-ratings/leaderboard`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetExpertRatingsLeaderboardQueryKey = (eventId: string) => {
  return [`/api/events/${eventId}/expert-ratings/leaderboard`] as const;
};

export const getGetExpertRatingsLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExpertRatingsLeaderboardQueryKey(eventId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>
  > = ({ signal }) =>
    getExpertRatingsLeaderboard(eventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExpertRatingsLeaderboardQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>
>;
export type GetExpertRatingsLeaderboardQueryError = PublicError;

export function useGetExpertRatingsLeaderboard<
  TData = Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpertRatingsLeaderboard<
  TData = Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpertRatingsLeaderboard<
  TData = Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExpertRatingsLeaderboard<
  TData = Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatingsLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExpertRatingsLeaderboardQueryOptions(
    eventId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const inviteUsers = (
  eventId: string,
  inviteUsersDTO: InviteUsersDTO,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ReducedUser[]>(
    {
      url: `/api/events/${eventId}/invite`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: inviteUsersDTO,
      signal,
    },
    options,
  );
};

export const getInviteUsersMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof inviteUsers>>,
    TError,
    { eventId: string; data: InviteUsersDTO },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof inviteUsers>>,
  TError,
  { eventId: string; data: InviteUsersDTO },
  TContext
> => {
  const mutationKey = ["inviteUsers"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof inviteUsers>>,
    { eventId: string; data: InviteUsersDTO }
  > = (props) => {
    const { eventId, data } = props ?? {};

    return inviteUsers(eventId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type InviteUsersMutationResult = NonNullable<
  Awaited<ReturnType<typeof inviteUsers>>
>;
export type InviteUsersMutationBody = InviteUsersDTO;
export type InviteUsersMutationError = PublicError;

export const useInviteUsers = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof inviteUsers>>,
      TError,
      { eventId: string; data: InviteUsersDTO },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof inviteUsers>>,
  TError,
  { eventId: string; data: InviteUsersDTO },
  TContext
> => {
  const mutationOptions = getInviteUsersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getLeaderboard = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>(
    { url: `/api/events/${eventId}/leaderboard`, method: "GET", signal },
    options,
  );
};

export const getGetLeaderboardQueryKey = (eventId: string) => {
  return [`/api/events/${eventId}/leaderboard`] as const;
};

export const getGetLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof getLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLeaderboardQueryKey(eventId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLeaderboard>>> = ({
    signal,
  }) => getLeaderboard(eventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getLeaderboard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLeaderboardQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLeaderboard>>
>;
export type GetLeaderboardQueryError = PublicError;

export function useGetLeaderboard<
  TData = Awaited<ReturnType<typeof getLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeaderboard<
  TData = Awaited<ReturnType<typeof getLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLeaderboard<
  TData = Awaited<ReturnType<typeof getLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetLeaderboard<
  TData = Awaited<ReturnType<typeof getLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLeaderboard>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLeaderboardQueryOptions(eventId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getProjectsMatching = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetProjectsMatching200>(
    { url: `/api/events/${eventId}/projects/matching`, method: "GET", signal },
    options,
  );
};

export const getGetProjectsMatchingQueryKey = (eventId: string) => {
  return [`/api/events/${eventId}/projects/matching`] as const;
};

export const getGetProjectsMatchingQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectsMatching>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectsMatching>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectsMatchingQueryKey(eventId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectsMatching>>
  > = ({ signal }) => getProjectsMatching(eventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectsMatching>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectsMatchingQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectsMatching>>
>;
export type GetProjectsMatchingQueryError = PublicError;

export function useGetProjectsMatching<
  TData = Awaited<ReturnType<typeof getProjectsMatching>>,
  TError = PublicError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectsMatching>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectsMatching>>,
          TError,
          Awaited<ReturnType<typeof getProjectsMatching>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProjectsMatching<
  TData = Awaited<ReturnType<typeof getProjectsMatching>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectsMatching>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectsMatching>>,
          TError,
          Awaited<ReturnType<typeof getProjectsMatching>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProjectsMatching<
  TData = Awaited<ReturnType<typeof getProjectsMatching>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectsMatching>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProjectsMatching<
  TData = Awaited<ReturnType<typeof getProjectsMatching>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectsMatching>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProjectsMatchingQueryOptions(eventId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getEventRoles = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EventRole[]>(
    { url: `/api/events/${eventId}/roles`, method: "GET", signal },
    options,
  );
};

export const getGetEventRolesQueryKey = (eventId: string) => {
  return [`/api/events/${eventId}/roles`] as const;
};

export const getGetEventRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventRoles>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEventRolesQueryKey(eventId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventRoles>>> = ({
    signal,
  }) => getEventRoles(eventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEventRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventRoles>>
>;
export type GetEventRolesQueryError = PublicError;

export function useGetEventRoles<
  TData = Awaited<ReturnType<typeof getEventRoles>>,
  TError = PublicError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventRoles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventRoles>>,
          TError,
          Awaited<ReturnType<typeof getEventRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventRoles<
  TData = Awaited<ReturnType<typeof getEventRoles>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventRoles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventRoles>>,
          TError,
          Awaited<ReturnType<typeof getEventRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventRoles<
  TData = Awaited<ReturnType<typeof getEventRoles>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetEventRoles<
  TData = Awaited<ReturnType<typeof getEventRoles>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventRolesQueryOptions(eventId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const putEventRoles = (
  eventId: string,
  putEventRolesBody: PutEventRolesBody,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AffectedRows>(
    {
      url: `/api/events/${eventId}/roles`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: putEventRolesBody,
    },
    options,
  );
};

export const getPutEventRolesMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putEventRoles>>,
    TError,
    { eventId: string; data: PutEventRolesBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putEventRoles>>,
  TError,
  { eventId: string; data: PutEventRolesBody },
  TContext
> => {
  const mutationKey = ["putEventRoles"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putEventRoles>>,
    { eventId: string; data: PutEventRolesBody }
  > = (props) => {
    const { eventId, data } = props ?? {};

    return putEventRoles(eventId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutEventRolesMutationResult = NonNullable<
  Awaited<ReturnType<typeof putEventRoles>>
>;
export type PutEventRolesMutationBody = PutEventRolesBody;
export type PutEventRolesMutationError = PublicError;

export const usePutEventRoles = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putEventRoles>>,
      TError,
      { eventId: string; data: PutEventRolesBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putEventRoles>>,
  TError,
  { eventId: string; data: PutEventRolesBody },
  TContext
> => {
  const mutationOptions = getPutEventRolesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteEventRoles = (
  eventId: string,
  deleteEventRolesBody: DeleteEventRolesBody,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AffectedRows>(
    {
      url: `/api/events/${eventId}/roles`,
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      data: deleteEventRolesBody,
    },
    options,
  );
};

export const getDeleteEventRolesMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteEventRoles>>,
    TError,
    { eventId: string; data: DeleteEventRolesBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteEventRoles>>,
  TError,
  { eventId: string; data: DeleteEventRolesBody },
  TContext
> => {
  const mutationKey = ["deleteEventRoles"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteEventRoles>>,
    { eventId: string; data: DeleteEventRolesBody }
  > = (props) => {
    const { eventId, data } = props ?? {};

    return deleteEventRoles(eventId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteEventRolesMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteEventRoles>>
>;
export type DeleteEventRolesMutationBody = DeleteEventRolesBody;
export type DeleteEventRolesMutationError = PublicError;

export const useDeleteEventRoles = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteEventRoles>>,
      TError,
      { eventId: string; data: DeleteEventRolesBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteEventRoles>>,
  TError,
  { eventId: string; data: DeleteEventRolesBody },
  TContext
> => {
  const mutationOptions = getDeleteEventRolesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSidequestsHistory = (
  eventId: string,
  params?: GetSidequestsHistoryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSidequestsHistory200>(
    {
      url: `/api/events/${eventId}/sidequests/history`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetSidequestsHistoryQueryKey = (
  eventId: string,
  params?: GetSidequestsHistoryParams,
) => {
  return [
    `/api/events/${eventId}/sidequests/history`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSidequestsHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestsHistory>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetSidequestsHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSidequestsHistoryQueryKey(eventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestsHistory>>
  > = ({ signal }) =>
    getSidequestsHistory(eventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestsHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestsHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestsHistory>>
>;
export type GetSidequestsHistoryQueryError = PublicError;

export function useGetSidequestsHistory<
  TData = Awaited<ReturnType<typeof getSidequestsHistory>>,
  TError = PublicError,
>(
  eventId: string,
  params: undefined | GetSidequestsHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsHistory>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsHistory<
  TData = Awaited<ReturnType<typeof getSidequestsHistory>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetSidequestsHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsHistory>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsHistory<
  TData = Awaited<ReturnType<typeof getSidequestsHistory>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetSidequestsHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestsHistory<
  TData = Awaited<ReturnType<typeof getSidequestsHistory>>,
  TError = PublicError,
>(
  eventId: string,
  params?: GetSidequestsHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestsHistoryQueryOptions(
    eventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSidequestsLeaderboard = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TeamLeaderboardEntry[]>(
    {
      url: `/api/events/${eventId}/sidequests/leaderboard`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetSidequestsLeaderboardQueryKey = (eventId: string) => {
  return [`/api/events/${eventId}/sidequests/leaderboard`] as const;
};

export const getGetSidequestsLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSidequestsLeaderboardQueryKey(eventId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestsLeaderboard>>
  > = ({ signal }) => getSidequestsLeaderboard(eventId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestsLeaderboardQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestsLeaderboard>>
>;
export type GetSidequestsLeaderboardQueryError = PublicError;

export function useGetSidequestsLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestsLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestsLeaderboardQueryOptions(
    eventId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSidequestsTeamLeaderboard = (
  eventId: string,
  params: GetSidequestsTeamLeaderboardParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TeamLeaderboardEntry[]>(
    {
      url: `/api/events/${eventId}/sidequests/team-leaderboard`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetSidequestsTeamLeaderboardQueryKey = (
  eventId: string,
  params: GetSidequestsTeamLeaderboardParams,
) => {
  return [
    `/api/events/${eventId}/sidequests/team-leaderboard`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSidequestsTeamLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsTeamLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSidequestsTeamLeaderboardQueryKey(eventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>
  > = ({ signal }) =>
    getSidequestsTeamLeaderboard(eventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestsTeamLeaderboardQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>
>;
export type GetSidequestsTeamLeaderboardQueryError = PublicError;

export function useGetSidequestsTeamLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsTeamLeaderboardParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsTeamLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsTeamLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsTeamLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsTeamLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestsTeamLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsTeamLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsTeamLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestsTeamLeaderboardQueryOptions(
    eventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSidequestsUserLeaderboard = (
  eventId: string,
  params: GetSidequestsUserLeaderboardParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserLeaderboardEntry[]>(
    {
      url: `/api/events/${eventId}/sidequests/user-leaderboard`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetSidequestsUserLeaderboardQueryKey = (
  eventId: string,
  params: GetSidequestsUserLeaderboardParams,
) => {
  return [
    `/api/events/${eventId}/sidequests/user-leaderboard`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSidequestsUserLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsUserLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSidequestsUserLeaderboardQueryKey(eventId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>
  > = ({ signal }) =>
    getSidequestsUserLeaderboard(eventId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!eventId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestsUserLeaderboardQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>
>;
export type GetSidequestsUserLeaderboardQueryError = PublicError;

export function useGetSidequestsUserLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsUserLeaderboardParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsUserLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsUserLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
          TError,
          Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestsUserLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsUserLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestsUserLeaderboard<
  TData = Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
  TError = PublicError,
>(
  eventId: string,
  params: GetSidequestsUserLeaderboardParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestsUserLeaderboard>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestsUserLeaderboardQueryOptions(
    eventId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const indexTeams = (
  eventId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team[]>(
    { url: `/api/events/${eventId}/teams/index`, method: "POST", signal },
    options,
  );
};

export const getIndexTeamsMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof indexTeams>>,
    TError,
    { eventId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof indexTeams>>,
  TError,
  { eventId: string },
  TContext
> => {
  const mutationKey = ["indexTeams"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof indexTeams>>,
    { eventId: string }
  > = (props) => {
    const { eventId } = props ?? {};

    return indexTeams(eventId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type IndexTeamsMutationResult = NonNullable<
  Awaited<ReturnType<typeof indexTeams>>
>;

export type IndexTeamsMutationError = PublicError;

export const useIndexTeams = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof indexTeams>>,
      TError,
      { eventId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof indexTeams>>,
  TError,
  { eventId: string },
  TContext
> => {
  const mutationOptions = getIndexTeamsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getExpertRatings = (
  params: GetExpertRatingsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExpertRating[]>(
    { url: `/api/expert-ratings`, method: "GET", params, signal },
    options,
  );
};

export const getGetExpertRatingsQueryKey = (params: GetExpertRatingsParams) => {
  return [`/api/expert-ratings`, ...(params ? [params] : [])] as const;
};

export const getGetExpertRatingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getExpertRatings>>,
  TError = PublicError,
>(
  params: GetExpertRatingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExpertRatingsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExpertRatings>>
  > = ({ signal }) => getExpertRatings(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExpertRatings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExpertRatingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExpertRatings>>
>;
export type GetExpertRatingsQueryError = PublicError;

export function useGetExpertRatings<
  TData = Awaited<ReturnType<typeof getExpertRatings>>,
  TError = PublicError,
>(
  params: GetExpertRatingsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatings>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpertRatings>>,
          TError,
          Awaited<ReturnType<typeof getExpertRatings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpertRatings<
  TData = Awaited<ReturnType<typeof getExpertRatings>>,
  TError = PublicError,
>(
  params: GetExpertRatingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatings>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpertRatings>>,
          TError,
          Awaited<ReturnType<typeof getExpertRatings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpertRatings<
  TData = Awaited<ReturnType<typeof getExpertRatings>>,
  TError = PublicError,
>(
  params: GetExpertRatingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExpertRatings<
  TData = Awaited<ReturnType<typeof getExpertRatings>>,
  TError = PublicError,
>(
  params: GetExpertRatingsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRatings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExpertRatingsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createExpertRating = (
  expertRatingForCreate: ExpertRatingForCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExpertRating>(
    {
      url: `/api/expert-ratings`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: expertRatingForCreate,
      signal,
    },
    options,
  );
};

export const getCreateExpertRatingMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createExpertRating>>,
    TError,
    { data: ExpertRatingForCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createExpertRating>>,
  TError,
  { data: ExpertRatingForCreate },
  TContext
> => {
  const mutationKey = ["createExpertRating"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createExpertRating>>,
    { data: ExpertRatingForCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createExpertRating(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateExpertRatingMutationResult = NonNullable<
  Awaited<ReturnType<typeof createExpertRating>>
>;
export type CreateExpertRatingMutationBody = ExpertRatingForCreate;
export type CreateExpertRatingMutationError = PublicError;

export const useCreateExpertRating = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createExpertRating>>,
      TError,
      { data: ExpertRatingForCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createExpertRating>>,
  TError,
  { data: ExpertRatingForCreate },
  TContext
> => {
  const mutationOptions = getCreateExpertRatingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getExpertRating = (
  ratingId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExpertRating>(
    { url: `/api/expert-ratings/${ratingId}`, method: "GET", signal },
    options,
  );
};

export const getGetExpertRatingQueryKey = (ratingId: string) => {
  return [`/api/expert-ratings/${ratingId}`] as const;
};

export const getGetExpertRatingQueryOptions = <
  TData = Awaited<ReturnType<typeof getExpertRating>>,
  TError = PublicError,
>(
  ratingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRating>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExpertRatingQueryKey(ratingId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExpertRating>>> = ({
    signal,
  }) => getExpertRating(ratingId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!ratingId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExpertRating>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExpertRatingQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExpertRating>>
>;
export type GetExpertRatingQueryError = PublicError;

export function useGetExpertRating<
  TData = Awaited<ReturnType<typeof getExpertRating>>,
  TError = PublicError,
>(
  ratingId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRating>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpertRating>>,
          TError,
          Awaited<ReturnType<typeof getExpertRating>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpertRating<
  TData = Awaited<ReturnType<typeof getExpertRating>>,
  TError = PublicError,
>(
  ratingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRating>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExpertRating>>,
          TError,
          Awaited<ReturnType<typeof getExpertRating>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExpertRating<
  TData = Awaited<ReturnType<typeof getExpertRating>>,
  TError = PublicError,
>(
  ratingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRating>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExpertRating<
  TData = Awaited<ReturnType<typeof getExpertRating>>,
  TError = PublicError,
>(
  ratingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExpertRating>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExpertRatingQueryOptions(ratingId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const deleteExpertRating = (
  ratingId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExpertRating>(
    { url: `/api/expert-ratings/${ratingId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteExpertRatingMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExpertRating>>,
    TError,
    { ratingId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteExpertRating>>,
  TError,
  { ratingId: string },
  TContext
> => {
  const mutationKey = ["deleteExpertRating"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteExpertRating>>,
    { ratingId: string }
  > = (props) => {
    const { ratingId } = props ?? {};

    return deleteExpertRating(ratingId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteExpertRatingMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteExpertRating>>
>;

export type DeleteExpertRatingMutationError = PublicError;

export const useDeleteExpertRating = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteExpertRating>>,
      TError,
      { ratingId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteExpertRating>>,
  TError,
  { ratingId: string },
  TContext
> => {
  const mutationOptions = getDeleteExpertRatingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateExpertRating = (
  ratingId: string,
  expertRatingForUpdate: ExpertRatingForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExpertRating>(
    {
      url: `/api/expert-ratings/${ratingId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: expertRatingForUpdate,
    },
    options,
  );
};

export const getUpdateExpertRatingMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateExpertRating>>,
    TError,
    { ratingId: string; data: ExpertRatingForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateExpertRating>>,
  TError,
  { ratingId: string; data: ExpertRatingForUpdate },
  TContext
> => {
  const mutationKey = ["updateExpertRating"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateExpertRating>>,
    { ratingId: string; data: ExpertRatingForUpdate }
  > = (props) => {
    const { ratingId, data } = props ?? {};

    return updateExpertRating(ratingId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateExpertRatingMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateExpertRating>>
>;
export type UpdateExpertRatingMutationBody = ExpertRatingForUpdate;
export type UpdateExpertRatingMutationError = PublicError;

export const useUpdateExpertRating = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateExpertRating>>,
      TError,
      { ratingId: string; data: ExpertRatingForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateExpertRating>>,
  TError,
  { ratingId: string; data: ExpertRatingForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateExpertRatingMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getProjects = (
  params: GetProjectsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Project[]>(
    { url: `/api/projects`, method: "GET", params, signal },
    options,
  );
};

export const getGetProjectsQueryKey = (params: GetProjectsParams) => {
  return [`/api/projects`, ...(params ? [params] : [])] as const;
};

export const getGetProjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjects>>,
  TError = PublicError,
>(
  params: GetProjectsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjects>>> = ({
    signal,
  }) => getProjects(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProjects>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjects>>
>;
export type GetProjectsQueryError = PublicError;

export function useGetProjects<
  TData = Awaited<ReturnType<typeof getProjects>>,
  TError = PublicError,
>(
  params: GetProjectsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjects>>,
          TError,
          Awaited<ReturnType<typeof getProjects>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProjects<
  TData = Awaited<ReturnType<typeof getProjects>>,
  TError = PublicError,
>(
  params: GetProjectsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjects>>,
          TError,
          Awaited<ReturnType<typeof getProjects>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProjects<
  TData = Awaited<ReturnType<typeof getProjects>>,
  TError = PublicError,
>(
  params: GetProjectsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProjects<
  TData = Awaited<ReturnType<typeof getProjects>>,
  TError = PublicError,
>(
  params: GetProjectsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProjectsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createProject = (
  projectForCreate: ProjectForCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Project>(
    {
      url: `/api/projects`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: projectForCreate,
      signal,
    },
    options,
  );
};

export const getCreateProjectMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProject>>,
    TError,
    { data: ProjectForCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProject>>,
  TError,
  { data: ProjectForCreate },
  TContext
> => {
  const mutationKey = ["createProject"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProject>>,
    { data: ProjectForCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createProject(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProject>>
>;
export type CreateProjectMutationBody = ProjectForCreate;
export type CreateProjectMutationError = PublicError;

export const useCreateProject = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProject>>,
      TError,
      { data: ProjectForCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProject>>,
  TError,
  { data: ProjectForCreate },
  TContext
> => {
  const mutationOptions = getCreateProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getProjectBySlug = (
  eventSlug: string,
  projectSlug: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Project>(
    {
      url: `/api/projects/slug/${eventSlug}/${projectSlug}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetProjectBySlugQueryKey = (
  eventSlug: string,
  projectSlug: string,
) => {
  return [`/api/projects/slug/${eventSlug}/${projectSlug}`] as const;
};

export const getGetProjectBySlugQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  projectSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectBySlug>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetProjectBySlugQueryKey(eventSlug, projectSlug);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectBySlug>>
  > = ({ signal }) =>
    getProjectBySlug(eventSlug, projectSlug, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(eventSlug && projectSlug),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectBySlug>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectBySlugQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectBySlug>>
>;
export type GetProjectBySlugQueryError = PublicError;

export function useGetProjectBySlug<
  TData = Awaited<ReturnType<typeof getProjectBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  projectSlug: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectBySlug>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectBySlug>>,
          TError,
          Awaited<ReturnType<typeof getProjectBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProjectBySlug<
  TData = Awaited<ReturnType<typeof getProjectBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  projectSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectBySlug>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProjectBySlug>>,
          TError,
          Awaited<ReturnType<typeof getProjectBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProjectBySlug<
  TData = Awaited<ReturnType<typeof getProjectBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  projectSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectBySlug>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProjectBySlug<
  TData = Awaited<ReturnType<typeof getProjectBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  projectSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectBySlug>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProjectBySlugQueryOptions(
    eventSlug,
    projectSlug,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getProject = (
  projectId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Project>(
    { url: `/api/projects/${projectId}`, method: "GET", signal },
    options,
  );
};

export const getGetProjectQueryKey = (projectId: string) => {
  return [`/api/projects/${projectId}`] as const;
};

export const getGetProjectQueryOptions = <
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = PublicError,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({
    signal,
  }) => getProject(projectId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProject>>
>;
export type GetProjectQueryError = PublicError;

export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = PublicError,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          Awaited<ReturnType<typeof getProject>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = PublicError,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          Awaited<ReturnType<typeof getProject>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = PublicError,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = PublicError,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProjectQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const deleteProject = (
  projectId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Project>(
    { url: `/api/projects/${projectId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteProjectMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProject>>,
    TError,
    { projectId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationKey = ["deleteProject"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProject>>,
    { projectId: string }
  > = (props) => {
    const { projectId } = props ?? {};

    return deleteProject(projectId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProject>>
>;

export type DeleteProjectMutationError = PublicError;

export const useDeleteProject = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProject>>,
      TError,
      { projectId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateProject = (
  projectId: string,
  projectForUpdate: ProjectForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Appointment>(
    {
      url: `/api/projects/${projectId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: projectForUpdate,
    },
    options,
  );
};

export const getUpdateProjectMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProject>>,
    TError,
    { projectId: string; data: ProjectForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProject>>,
  TError,
  { projectId: string; data: ProjectForUpdate },
  TContext
> => {
  const mutationKey = ["updateProject"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProject>>,
    { projectId: string; data: ProjectForUpdate }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return updateProject(projectId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProject>>
>;
export type UpdateProjectMutationBody = ProjectForUpdate;
export type UpdateProjectMutationError = PublicError;

export const useUpdateProject = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProject>>,
      TError,
      { projectId: string; data: ProjectForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateProject>>,
  TError,
  { projectId: string; data: ProjectForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSidequestAttempts = (
  params: GetSidequestAttemptsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Attempt[]>(
    { url: `/api/sidequest-attempts`, method: "GET", params, signal },
    options,
  );
};

export const getGetSidequestAttemptsQueryKey = (
  params: GetSidequestAttemptsParams,
) => {
  return [`/api/sidequest-attempts`, ...(params ? [params] : [])] as const;
};

export const getGetSidequestAttemptsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestAttempts>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSidequestAttemptsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestAttempts>>
  > = ({ signal }) => getSidequestAttempts(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestAttempts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestAttemptsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestAttempts>>
>;
export type GetSidequestAttemptsQueryError = PublicError;

export function useGetSidequestAttempts<
  TData = Awaited<ReturnType<typeof getSidequestAttempts>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempts>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestAttempts>>,
          TError,
          Awaited<ReturnType<typeof getSidequestAttempts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestAttempts<
  TData = Awaited<ReturnType<typeof getSidequestAttempts>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempts>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestAttempts>>,
          TError,
          Awaited<ReturnType<typeof getSidequestAttempts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestAttempts<
  TData = Awaited<ReturnType<typeof getSidequestAttempts>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestAttempts<
  TData = Awaited<ReturnType<typeof getSidequestAttempts>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestAttemptsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createSidequestAttempt = (
  attemptForCreate: AttemptForCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Attempt>(
    {
      url: `/api/sidequest-attempts`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: attemptForCreate,
      signal,
    },
    options,
  );
};

export const getCreateSidequestAttemptMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSidequestAttempt>>,
    TError,
    { data: AttemptForCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSidequestAttempt>>,
  TError,
  { data: AttemptForCreate },
  TContext
> => {
  const mutationKey = ["createSidequestAttempt"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSidequestAttempt>>,
    { data: AttemptForCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createSidequestAttempt(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSidequestAttemptMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSidequestAttempt>>
>;
export type CreateSidequestAttemptMutationBody = AttemptForCreate;
export type CreateSidequestAttemptMutationError = PublicError;

export const useCreateSidequestAttempt = <
  TError = PublicError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSidequestAttempt>>,
      TError,
      { data: AttemptForCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSidequestAttempt>>,
  TError,
  { data: AttemptForCreate },
  TContext
> => {
  const mutationOptions = getCreateSidequestAttemptMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSidequestAttemptCooldown = (
  params: GetSidequestAttemptCooldownParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Cooldown>(
    { url: `/api/sidequest-attempts/cooldown`, method: "GET", params, signal },
    options,
  );
};

export const getGetSidequestAttemptCooldownQueryKey = (
  params: GetSidequestAttemptCooldownParams,
) => {
  return [
    `/api/sidequest-attempts/cooldown`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSidequestAttemptCooldownQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptCooldownParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSidequestAttemptCooldownQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestAttemptCooldown>>
  > = ({ signal }) =>
    getSidequestAttemptCooldown(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestAttemptCooldownQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestAttemptCooldown>>
>;
export type GetSidequestAttemptCooldownQueryError = PublicError;

export function useGetSidequestAttemptCooldown<
  TData = Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptCooldownParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
          TError,
          Awaited<ReturnType<typeof getSidequestAttemptCooldown>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestAttemptCooldown<
  TData = Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptCooldownParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
          TError,
          Awaited<ReturnType<typeof getSidequestAttemptCooldown>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestAttemptCooldown<
  TData = Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptCooldownParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestAttemptCooldown<
  TData = Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
  TError = PublicError,
>(
  params: GetSidequestAttemptCooldownParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttemptCooldown>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestAttemptCooldownQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSidequestAttempt = (
  sidequestAttemptId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Attempt>(
    {
      url: `/api/sidequest-attempts/${sidequestAttemptId}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetSidequestAttemptQueryKey = (sidequestAttemptId: string) => {
  return [`/api/sidequest-attempts/${sidequestAttemptId}`] as const;
};

export const getGetSidequestAttemptQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestAttempt>>,
  TError = PublicError,
>(
  sidequestAttemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempt>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSidequestAttemptQueryKey(sidequestAttemptId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestAttempt>>
  > = ({ signal }) =>
    getSidequestAttempt(sidequestAttemptId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!sidequestAttemptId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestAttempt>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestAttemptQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestAttempt>>
>;
export type GetSidequestAttemptQueryError = PublicError;

export function useGetSidequestAttempt<
  TData = Awaited<ReturnType<typeof getSidequestAttempt>>,
  TError = PublicError,
>(
  sidequestAttemptId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempt>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestAttempt>>,
          TError,
          Awaited<ReturnType<typeof getSidequestAttempt>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestAttempt<
  TData = Awaited<ReturnType<typeof getSidequestAttempt>>,
  TError = PublicError,
>(
  sidequestAttemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempt>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestAttempt>>,
          TError,
          Awaited<ReturnType<typeof getSidequestAttempt>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestAttempt<
  TData = Awaited<ReturnType<typeof getSidequestAttempt>>,
  TError = PublicError,
>(
  sidequestAttemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempt>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestAttempt<
  TData = Awaited<ReturnType<typeof getSidequestAttempt>>,
  TError = PublicError,
>(
  sidequestAttemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestAttempt>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestAttemptQueryOptions(
    sidequestAttemptId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const deleteSidequestAttempt = (
  sidequestAttemptId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteSidequestAttempt200>(
    { url: `/api/sidequest-attempts/${sidequestAttemptId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteSidequestAttemptMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSidequestAttempt>>,
    TError,
    { sidequestAttemptId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSidequestAttempt>>,
  TError,
  { sidequestAttemptId: string },
  TContext
> => {
  const mutationKey = ["deleteSidequestAttempt"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSidequestAttempt>>,
    { sidequestAttemptId: string }
  > = (props) => {
    const { sidequestAttemptId } = props ?? {};

    return deleteSidequestAttempt(sidequestAttemptId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSidequestAttemptMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSidequestAttempt>>
>;

export type DeleteSidequestAttemptMutationError = PublicError;

export const useDeleteSidequestAttempt = <
  TError = PublicError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSidequestAttempt>>,
      TError,
      { sidequestAttemptId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSidequestAttempt>>,
  TError,
  { sidequestAttemptId: string },
  TContext
> => {
  const mutationOptions = getDeleteSidequestAttemptMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateSidequestAttempt = (
  sidequestAttemptId: string,
  attemptForUpdate: AttemptForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Attempt>(
    {
      url: `/api/sidequest-attempts/${sidequestAttemptId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: attemptForUpdate,
    },
    options,
  );
};

export const getUpdateSidequestAttemptMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSidequestAttempt>>,
    TError,
    { sidequestAttemptId: string; data: AttemptForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSidequestAttempt>>,
  TError,
  { sidequestAttemptId: string; data: AttemptForUpdate },
  TContext
> => {
  const mutationKey = ["updateSidequestAttempt"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSidequestAttempt>>,
    { sidequestAttemptId: string; data: AttemptForUpdate }
  > = (props) => {
    const { sidequestAttemptId, data } = props ?? {};

    return updateSidequestAttempt(sidequestAttemptId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSidequestAttemptMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSidequestAttempt>>
>;
export type UpdateSidequestAttemptMutationBody = AttemptForUpdate;
export type UpdateSidequestAttemptMutationError = PublicError;

export const useUpdateSidequestAttempt = <
  TError = PublicError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSidequestAttempt>>,
      TError,
      { sidequestAttemptId: string; data: AttemptForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSidequestAttempt>>,
  TError,
  { sidequestAttemptId: string; data: AttemptForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateSidequestAttemptMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSidequests = (
  params: GetSidequestsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Sidequest[]>(
    { url: `/api/sidequests`, method: "GET", params, signal },
    options,
  );
};

export const getGetSidequestsQueryKey = (params: GetSidequestsParams) => {
  return [`/api/sidequests`, ...(params ? [params] : [])] as const;
};

export const getGetSidequestsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequests>>,
  TError = PublicError,
>(
  params: GetSidequestsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequests>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSidequestsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSidequests>>> = ({
    signal,
  }) => getSidequests(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequests>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequests>>
>;
export type GetSidequestsQueryError = PublicError;

export function useGetSidequests<
  TData = Awaited<ReturnType<typeof getSidequests>>,
  TError = PublicError,
>(
  params: GetSidequestsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequests>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequests>>,
          TError,
          Awaited<ReturnType<typeof getSidequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequests<
  TData = Awaited<ReturnType<typeof getSidequests>>,
  TError = PublicError,
>(
  params: GetSidequestsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequests>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequests>>,
          TError,
          Awaited<ReturnType<typeof getSidequests>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequests<
  TData = Awaited<ReturnType<typeof getSidequests>>,
  TError = PublicError,
>(
  params: GetSidequestsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequests>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequests<
  TData = Awaited<ReturnType<typeof getSidequests>>,
  TError = PublicError,
>(
  params: GetSidequestsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequests>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createSidequest = (
  sidequestForCreate: SidequestForCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SidequestForCreate>(
    {
      url: `/api/sidequests`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: sidequestForCreate,
      signal,
    },
    options,
  );
};

export const getCreateSidequestMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSidequest>>,
    TError,
    { data: SidequestForCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSidequest>>,
  TError,
  { data: SidequestForCreate },
  TContext
> => {
  const mutationKey = ["createSidequest"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSidequest>>,
    { data: SidequestForCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createSidequest(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSidequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSidequest>>
>;
export type CreateSidequestMutationBody = SidequestForCreate;
export type CreateSidequestMutationError = PublicError;

export const useCreateSidequest = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSidequest>>,
      TError,
      { data: SidequestForCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSidequest>>,
  TError,
  { data: SidequestForCreate },
  TContext
> => {
  const mutationOptions = getCreateSidequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSidequestBySlug = (
  eventSlug: string,
  sidequestSlug: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Sidequest>(
    {
      url: `/api/sidequests/slug/${eventSlug}/${sidequestSlug}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetSidequestBySlugQueryKey = (
  eventSlug: string,
  sidequestSlug: string,
) => {
  return [`/api/sidequests/slug/${eventSlug}/${sidequestSlug}`] as const;
};

export const getGetSidequestBySlugQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequestBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  sidequestSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestBySlug>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSidequestBySlugQueryKey(eventSlug, sidequestSlug);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSidequestBySlug>>
  > = ({ signal }) =>
    getSidequestBySlug(eventSlug, sidequestSlug, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(eventSlug && sidequestSlug),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequestBySlug>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestBySlugQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequestBySlug>>
>;
export type GetSidequestBySlugQueryError = PublicError;

export function useGetSidequestBySlug<
  TData = Awaited<ReturnType<typeof getSidequestBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  sidequestSlug: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestBySlug>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestBySlug>>,
          TError,
          Awaited<ReturnType<typeof getSidequestBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestBySlug<
  TData = Awaited<ReturnType<typeof getSidequestBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  sidequestSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestBySlug>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequestBySlug>>,
          TError,
          Awaited<ReturnType<typeof getSidequestBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequestBySlug<
  TData = Awaited<ReturnType<typeof getSidequestBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  sidequestSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestBySlug>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequestBySlug<
  TData = Awaited<ReturnType<typeof getSidequestBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  sidequestSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSidequestBySlug>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestBySlugQueryOptions(
    eventSlug,
    sidequestSlug,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSidequest = (
  sidequestId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Sidequest>(
    { url: `/api/sidequests/${sidequestId}`, method: "GET", signal },
    options,
  );
};

export const getGetSidequestQueryKey = (sidequestId: string) => {
  return [`/api/sidequests/${sidequestId}`] as const;
};

export const getGetSidequestQueryOptions = <
  TData = Awaited<ReturnType<typeof getSidequest>>,
  TError = PublicError,
>(
  sidequestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequest>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSidequestQueryKey(sidequestId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSidequest>>> = ({
    signal,
  }) => getSidequest(sidequestId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!sidequestId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSidequest>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSidequestQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSidequest>>
>;
export type GetSidequestQueryError = PublicError;

export function useGetSidequest<
  TData = Awaited<ReturnType<typeof getSidequest>>,
  TError = PublicError,
>(
  sidequestId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequest>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequest>>,
          TError,
          Awaited<ReturnType<typeof getSidequest>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequest<
  TData = Awaited<ReturnType<typeof getSidequest>>,
  TError = PublicError,
>(
  sidequestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequest>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSidequest>>,
          TError,
          Awaited<ReturnType<typeof getSidequest>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSidequest<
  TData = Awaited<ReturnType<typeof getSidequest>>,
  TError = PublicError,
>(
  sidequestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequest>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSidequest<
  TData = Awaited<ReturnType<typeof getSidequest>>,
  TError = PublicError,
>(
  sidequestId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSidequest>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSidequestQueryOptions(sidequestId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const deleteSidequest = (
  sidequestId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteSidequest200>(
    { url: `/api/sidequests/${sidequestId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteSidequestMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSidequest>>,
    TError,
    { sidequestId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSidequest>>,
  TError,
  { sidequestId: string },
  TContext
> => {
  const mutationKey = ["deleteSidequest"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSidequest>>,
    { sidequestId: string }
  > = (props) => {
    const { sidequestId } = props ?? {};

    return deleteSidequest(sidequestId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSidequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSidequest>>
>;

export type DeleteSidequestMutationError = PublicError;

export const useDeleteSidequest = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSidequest>>,
      TError,
      { sidequestId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSidequest>>,
  TError,
  { sidequestId: string },
  TContext
> => {
  const mutationOptions = getDeleteSidequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateSidequest = (
  sidequestId: string,
  sidequestForUpdate: SidequestForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Sidequest>(
    {
      url: `/api/sidequests/${sidequestId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: sidequestForUpdate,
    },
    options,
  );
};

export const getUpdateSidequestMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSidequest>>,
    TError,
    { sidequestId: string; data: SidequestForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSidequest>>,
  TError,
  { sidequestId: string; data: SidequestForUpdate },
  TContext
> => {
  const mutationKey = ["updateSidequest"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSidequest>>,
    { sidequestId: string; data: SidequestForUpdate }
  > = (props) => {
    const { sidequestId, data } = props ?? {};

    return updateSidequest(sidequestId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSidequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSidequest>>
>;
export type UpdateSidequestMutationBody = SidequestForUpdate;
export type UpdateSidequestMutationError = PublicError;

export const useUpdateSidequest = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSidequest>>,
      TError,
      { sidequestId: string; data: SidequestForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSidequest>>,
  TError,
  { sidequestId: string; data: SidequestForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateSidequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTeams = (
  params: GetTeamsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team[]>(
    { url: `/api/teams`, method: "GET", params, signal },
    options,
  );
};

export const getGetTeamsQueryKey = (params: GetTeamsParams) => {
  return [`/api/teams`, ...(params ? [params] : [])] as const;
};

export const getGetTeamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeams>>,
  TError = PublicError,
>(
  params: GetTeamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTeamsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeams>>> = ({
    signal,
  }) => getTeams(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeams>>
>;
export type GetTeamsQueryError = PublicError;

export function useGetTeams<
  TData = Awaited<ReturnType<typeof getTeams>>,
  TError = PublicError,
>(
  params: GetTeamsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeams>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeams>>,
          TError,
          Awaited<ReturnType<typeof getTeams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeams<
  TData = Awaited<ReturnType<typeof getTeams>>,
  TError = PublicError,
>(
  params: GetTeamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeams>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeams>>,
          TError,
          Awaited<ReturnType<typeof getTeams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeams<
  TData = Awaited<ReturnType<typeof getTeams>>,
  TError = PublicError,
>(
  params: GetTeamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeams<
  TData = Awaited<ReturnType<typeof getTeams>>,
  TError = PublicError,
>(
  params: GetTeamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createTeam = (
  teamForCreate: TeamForCreate,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team>(
    {
      url: `/api/teams`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: teamForCreate,
      signal,
    },
    options,
  );
};

export const getCreateTeamMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTeam>>,
    TError,
    { data: TeamForCreate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTeam>>,
  TError,
  { data: TeamForCreate },
  TContext
> => {
  const mutationKey = ["createTeam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTeam>>,
    { data: TeamForCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createTeam(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTeamMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTeam>>
>;
export type CreateTeamMutationBody = TeamForCreate;
export type CreateTeamMutationError = PublicError;

export const useCreateTeam = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTeam>>,
      TError,
      { data: TeamForCreate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTeam>>,
  TError,
  { data: TeamForCreate },
  TContext
> => {
  const mutationOptions = getCreateTeamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTeamsInternal = (
  params: GetTeamsInternalParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TeamInternal[]>(
    { url: `/api/teams/internal`, method: "GET", params, signal },
    options,
  );
};

export const getGetTeamsInternalQueryKey = (params: GetTeamsInternalParams) => {
  return [`/api/teams/internal`, ...(params ? [params] : [])] as const;
};

export const getGetTeamsInternalQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamsInternal>>,
  TError = PublicError,
>(
  params: GetTeamsInternalParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsInternal>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamsInternalQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamsInternal>>
  > = ({ signal }) => getTeamsInternal(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamsInternal>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamsInternalQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamsInternal>>
>;
export type GetTeamsInternalQueryError = PublicError;

export function useGetTeamsInternal<
  TData = Awaited<ReturnType<typeof getTeamsInternal>>,
  TError = PublicError,
>(
  params: GetTeamsInternalParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsInternal>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamsInternal>>,
          TError,
          Awaited<ReturnType<typeof getTeamsInternal>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamsInternal<
  TData = Awaited<ReturnType<typeof getTeamsInternal>>,
  TError = PublicError,
>(
  params: GetTeamsInternalParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsInternal>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamsInternal>>,
          TError,
          Awaited<ReturnType<typeof getTeamsInternal>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamsInternal<
  TData = Awaited<ReturnType<typeof getTeamsInternal>>,
  TError = PublicError,
>(
  params: GetTeamsInternalParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsInternal>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamsInternal<
  TData = Awaited<ReturnType<typeof getTeamsInternal>>,
  TError = PublicError,
>(
  params: GetTeamsInternalParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamsInternal>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamsInternalQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTeamsRoles = (
  params: GetTeamsRolesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTeamsRoles200>(
    { url: `/api/teams/roles`, method: "GET", params, signal },
    options,
  );
};

export const getGetTeamsRolesQueryKey = (params: GetTeamsRolesParams) => {
  return [`/api/teams/roles`, ...(params ? [params] : [])] as const;
};

export const getGetTeamsRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamsRoles>>,
  TError = PublicError,
>(
  params: GetTeamsRolesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamsRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTeamsRolesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeamsRoles>>> = ({
    signal,
  }) => getTeamsRoles(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamsRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamsRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamsRoles>>
>;
export type GetTeamsRolesQueryError = PublicError;

export function useGetTeamsRoles<
  TData = Awaited<ReturnType<typeof getTeamsRoles>>,
  TError = PublicError,
>(
  params: GetTeamsRolesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamsRoles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamsRoles>>,
          TError,
          Awaited<ReturnType<typeof getTeamsRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamsRoles<
  TData = Awaited<ReturnType<typeof getTeamsRoles>>,
  TError = PublicError,
>(
  params: GetTeamsRolesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamsRoles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamsRoles>>,
          TError,
          Awaited<ReturnType<typeof getTeamsRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamsRoles<
  TData = Awaited<ReturnType<typeof getTeamsRoles>>,
  TError = PublicError,
>(
  params: GetTeamsRolesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamsRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamsRoles<
  TData = Awaited<ReturnType<typeof getTeamsRoles>>,
  TError = PublicError,
>(
  params: GetTeamsRolesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamsRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamsRolesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTeamBySlug = (
  eventSlug: string,
  teamSlug: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team>(
    { url: `/api/teams/slug/${eventSlug}/${teamSlug}`, method: "GET", signal },
    options,
  );
};

export const getGetTeamBySlugQueryKey = (
  eventSlug: string,
  teamSlug: string,
) => {
  return [`/api/teams/slug/${eventSlug}/${teamSlug}`] as const;
};

export const getGetTeamBySlugQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  teamSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamBySlug>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamBySlugQueryKey(eventSlug, teamSlug);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeamBySlug>>> = ({
    signal,
  }) => getTeamBySlug(eventSlug, teamSlug, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(eventSlug && teamSlug),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamBySlug>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamBySlugQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamBySlug>>
>;
export type GetTeamBySlugQueryError = PublicError;

export function useGetTeamBySlug<
  TData = Awaited<ReturnType<typeof getTeamBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  teamSlug: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamBySlug>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamBySlug>>,
          TError,
          Awaited<ReturnType<typeof getTeamBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamBySlug<
  TData = Awaited<ReturnType<typeof getTeamBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  teamSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamBySlug>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamBySlug>>,
          TError,
          Awaited<ReturnType<typeof getTeamBySlug>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamBySlug<
  TData = Awaited<ReturnType<typeof getTeamBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  teamSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamBySlug>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamBySlug<
  TData = Awaited<ReturnType<typeof getTeamBySlug>>,
  TError = PublicError,
>(
  eventSlug: string,
  teamSlug: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamBySlug>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamBySlugQueryOptions(
    eventSlug,
    teamSlug,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTeam = (
  teamId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team>(
    { url: `/api/teams/${teamId}`, method: "GET", signal },
    options,
  );
};

export const getGetTeamQueryKey = (teamId: string) => {
  return [`/api/teams/${teamId}`] as const;
};

export const getGetTeamQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTeamQueryKey(teamId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeam>>> = ({
    signal,
  }) => getTeam(teamId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTeamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeam>>
>;
export type GetTeamQueryError = PublicError;

export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = PublicError,
>(
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeam>>,
          TError,
          Awaited<ReturnType<typeof getTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeam>>,
          TError,
          Awaited<ReturnType<typeof getTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamQueryOptions(teamId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const deleteTeam = (
  teamId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Team>(
    { url: `/api/teams/${teamId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteTeamMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTeam>>,
    TError,
    { teamId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTeam>>,
  TError,
  { teamId: string },
  TContext
> => {
  const mutationKey = ["deleteTeam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTeam>>,
    { teamId: string }
  > = (props) => {
    const { teamId } = props ?? {};

    return deleteTeam(teamId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTeamMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTeam>>
>;

export type DeleteTeamMutationError = PublicError;

export const useDeleteTeam = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTeam>>,
      TError,
      { teamId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTeam>>,
  TError,
  { teamId: string },
  TContext
> => {
  const mutationOptions = getDeleteTeamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateTeam = (
  teamId: string,
  teamForUpdate: TeamForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Team>(
    {
      url: `/api/teams/${teamId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: teamForUpdate,
    },
    options,
  );
};

export const getUpdateTeamMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeam>>,
    TError,
    { teamId: string; data: TeamForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeam>>,
  TError,
  { teamId: string; data: TeamForUpdate },
  TContext
> => {
  const mutationKey = ["updateTeam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeam>>,
    { teamId: string; data: TeamForUpdate }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return updateTeam(teamId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeam>>
>;
export type UpdateTeamMutationBody = TeamForUpdate;
export type UpdateTeamMutationError = PublicError;

export const useUpdateTeam = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeam>>,
      TError,
      { teamId: string; data: TeamForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeam>>,
  TError,
  { teamId: string; data: TeamForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateTeamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTeamAffiliates = (
  teamId: string,
  params?: GetTeamAffiliatesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TeamAffiliate[]>(
    { url: `/api/teams/${teamId}/affiliates`, method: "GET", params, signal },
    options,
  );
};

export const getGetTeamAffiliatesQueryKey = (
  teamId: string,
  params?: GetTeamAffiliatesParams,
) => {
  return [
    `/api/teams/${teamId}/affiliates`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetTeamAffiliatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamAffiliates>>,
  TError = PublicError,
>(
  teamId: string,
  params?: GetTeamAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamAffiliates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamAffiliatesQueryKey(teamId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamAffiliates>>
  > = ({ signal }) => getTeamAffiliates(teamId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamAffiliates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamAffiliatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamAffiliates>>
>;
export type GetTeamAffiliatesQueryError = PublicError;

export function useGetTeamAffiliates<
  TData = Awaited<ReturnType<typeof getTeamAffiliates>>,
  TError = PublicError,
>(
  teamId: string,
  params: undefined | GetTeamAffiliatesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamAffiliates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamAffiliates>>,
          TError,
          Awaited<ReturnType<typeof getTeamAffiliates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamAffiliates<
  TData = Awaited<ReturnType<typeof getTeamAffiliates>>,
  TError = PublicError,
>(
  teamId: string,
  params?: GetTeamAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamAffiliates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamAffiliates>>,
          TError,
          Awaited<ReturnType<typeof getTeamAffiliates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamAffiliates<
  TData = Awaited<ReturnType<typeof getTeamAffiliates>>,
  TError = PublicError,
>(
  teamId: string,
  params?: GetTeamAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamAffiliates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamAffiliates<
  TData = Awaited<ReturnType<typeof getTeamAffiliates>>,
  TError = PublicError,
>(
  teamId: string,
  params?: GetTeamAffiliatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamAffiliates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamAffiliatesQueryOptions(
    teamId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTeamCredentials = (
  teamId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TeamCredentials>(
    { url: `/api/teams/${teamId}/credentials`, method: "GET", signal },
    options,
  );
};

export const getGetTeamCredentialsQueryKey = (teamId: string) => {
  return [`/api/teams/${teamId}/credentials`] as const;
};

export const getGetTeamCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamCredentials>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamCredentials>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamCredentialsQueryKey(teamId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamCredentials>>
  > = ({ signal }) => getTeamCredentials(teamId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamCredentials>>
>;
export type GetTeamCredentialsQueryError = PublicError;

export function useGetTeamCredentials<
  TData = Awaited<ReturnType<typeof getTeamCredentials>>,
  TError = PublicError,
>(
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamCredentials>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamCredentials>>,
          TError,
          Awaited<ReturnType<typeof getTeamCredentials>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamCredentials<
  TData = Awaited<ReturnType<typeof getTeamCredentials>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamCredentials>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamCredentials>>,
          TError,
          Awaited<ReturnType<typeof getTeamCredentials>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamCredentials<
  TData = Awaited<ReturnType<typeof getTeamCredentials>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamCredentials>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamCredentials<
  TData = Awaited<ReturnType<typeof getTeamCredentials>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamCredentials>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamCredentialsQueryOptions(teamId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTeamCredentials = (
  teamId: string,
  teamCredentials: TeamCredentials,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Team>(
    {
      url: `/api/teams/${teamId}/credentials`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: teamCredentials,
    },
    options,
  );
};

export const getUpdateTeamCredentialsMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamCredentials>>,
    TError,
    { teamId: string; data: TeamCredentials },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamCredentials>>,
  TError,
  { teamId: string; data: TeamCredentials },
  TContext
> => {
  const mutationKey = ["updateTeamCredentials"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamCredentials>>,
    { teamId: string; data: TeamCredentials }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return updateTeamCredentials(teamId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamCredentialsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamCredentials>>
>;
export type UpdateTeamCredentialsMutationBody = TeamCredentials;
export type UpdateTeamCredentialsMutationError = PublicError;

export const useUpdateTeamCredentials = <
  TError = PublicError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamCredentials>>,
      TError,
      { teamId: string; data: TeamCredentials },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamCredentials>>,
  TError,
  { teamId: string; data: TeamCredentials },
  TContext
> => {
  const mutationOptions = getUpdateTeamCredentialsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTeamExpertRatings = (
  teamId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTeamExpertRatings200>(
    { url: `/api/teams/${teamId}/expert-ratings`, method: "GET", signal },
    options,
  );
};

export const getGetTeamExpertRatingsQueryKey = (teamId: string) => {
  return [`/api/teams/${teamId}/expert-ratings`] as const;
};

export const getGetTeamExpertRatingsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamExpertRatings>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamExpertRatings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamExpertRatingsQueryKey(teamId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamExpertRatings>>
  > = ({ signal }) => getTeamExpertRatings(teamId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamExpertRatings>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamExpertRatingsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamExpertRatings>>
>;
export type GetTeamExpertRatingsQueryError = PublicError;

export function useGetTeamExpertRatings<
  TData = Awaited<ReturnType<typeof getTeamExpertRatings>>,
  TError = PublicError,
>(
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamExpertRatings>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamExpertRatings>>,
          TError,
          Awaited<ReturnType<typeof getTeamExpertRatings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamExpertRatings<
  TData = Awaited<ReturnType<typeof getTeamExpertRatings>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamExpertRatings>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamExpertRatings>>,
          TError,
          Awaited<ReturnType<typeof getTeamExpertRatings>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamExpertRatings<
  TData = Awaited<ReturnType<typeof getTeamExpertRatings>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamExpertRatings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamExpertRatings<
  TData = Awaited<ReturnType<typeof getTeamExpertRatings>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamExpertRatings>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamExpertRatingsQueryOptions(teamId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTeamInternal = (
  teamId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TeamInternal>(
    { url: `/api/teams/${teamId}/internal`, method: "GET", signal },
    options,
  );
};

export const getGetTeamInternalQueryKey = (teamId: string) => {
  return [`/api/teams/${teamId}/internal`] as const;
};

export const getGetTeamInternalQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamInternal>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamInternal>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTeamInternalQueryKey(teamId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeamInternal>>> = ({
    signal,
  }) => getTeamInternal(teamId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamInternal>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamInternalQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamInternal>>
>;
export type GetTeamInternalQueryError = PublicError;

export function useGetTeamInternal<
  TData = Awaited<ReturnType<typeof getTeamInternal>>,
  TError = PublicError,
>(
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamInternal>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamInternal>>,
          TError,
          Awaited<ReturnType<typeof getTeamInternal>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamInternal<
  TData = Awaited<ReturnType<typeof getTeamInternal>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamInternal>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamInternal>>,
          TError,
          Awaited<ReturnType<typeof getTeamInternal>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamInternal<
  TData = Awaited<ReturnType<typeof getTeamInternal>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamInternal>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamInternal<
  TData = Awaited<ReturnType<typeof getTeamInternal>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamInternal>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamInternalQueryOptions(teamId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTeamInternal = (
  teamId: string,
  teamForUpdateInternal: TeamForUpdateInternal,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<TeamInternal>(
    {
      url: `/api/teams/${teamId}/internal`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: teamForUpdateInternal,
    },
    options,
  );
};

export const getUpdateTeamInternalMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamInternal>>,
    TError,
    { teamId: string; data: TeamForUpdateInternal },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamInternal>>,
  TError,
  { teamId: string; data: TeamForUpdateInternal },
  TContext
> => {
  const mutationKey = ["updateTeamInternal"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamInternal>>,
    { teamId: string; data: TeamForUpdateInternal }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return updateTeamInternal(teamId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamInternalMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamInternal>>
>;
export type UpdateTeamInternalMutationBody = TeamForUpdateInternal;
export type UpdateTeamInternalMutationError = PublicError;

export const useUpdateTeamInternal = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamInternal>>,
      TError,
      { teamId: string; data: TeamForUpdateInternal },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamInternal>>,
  TError,
  { teamId: string; data: TeamForUpdateInternal },
  TContext
> => {
  const mutationOptions = getUpdateTeamInternalMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateTeamProject = (
  teamId: string,
  projectIdDTO: ProjectIdDTO,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Team>(
    {
      url: `/api/teams/${teamId}/project`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: projectIdDTO,
    },
    options,
  );
};

export const getUpdateTeamProjectMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamProject>>,
    TError,
    { teamId: string; data: ProjectIdDTO },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamProject>>,
  TError,
  { teamId: string; data: ProjectIdDTO },
  TContext
> => {
  const mutationKey = ["updateTeamProject"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamProject>>,
    { teamId: string; data: ProjectIdDTO }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return updateTeamProject(teamId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamProject>>
>;
export type UpdateTeamProjectMutationBody = ProjectIdDTO;
export type UpdateTeamProjectMutationError = PublicError;

export const useUpdateTeamProject = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamProject>>,
      TError,
      { teamId: string; data: ProjectIdDTO },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamProject>>,
  TError,
  { teamId: string; data: ProjectIdDTO },
  TContext
> => {
  const mutationOptions = getUpdateTeamProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTeamProjectPreferences = (
  teamId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>(
    { url: `/api/teams/${teamId}/project-preferences`, method: "GET", signal },
    options,
  );
};

export const getGetTeamProjectPreferencesQueryKey = (teamId: string) => {
  return [`/api/teams/${teamId}/project-preferences`] as const;
};

export const getGetTeamProjectPreferencesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamProjectPreferences>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamProjectPreferences>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamProjectPreferencesQueryKey(teamId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamProjectPreferences>>
  > = ({ signal }) => getTeamProjectPreferences(teamId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamProjectPreferences>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamProjectPreferencesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamProjectPreferences>>
>;
export type GetTeamProjectPreferencesQueryError = PublicError;

export function useGetTeamProjectPreferences<
  TData = Awaited<ReturnType<typeof getTeamProjectPreferences>>,
  TError = PublicError,
>(
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamProjectPreferences>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamProjectPreferences>>,
          TError,
          Awaited<ReturnType<typeof getTeamProjectPreferences>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamProjectPreferences<
  TData = Awaited<ReturnType<typeof getTeamProjectPreferences>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamProjectPreferences>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamProjectPreferences>>,
          TError,
          Awaited<ReturnType<typeof getTeamProjectPreferences>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamProjectPreferences<
  TData = Awaited<ReturnType<typeof getTeamProjectPreferences>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamProjectPreferences>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamProjectPreferences<
  TData = Awaited<ReturnType<typeof getTeamProjectPreferences>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamProjectPreferences>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamProjectPreferencesQueryOptions(
    teamId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTeamProjectPreferences = (
  teamId: string,
  updateTeamProjectPreferencesBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string[]>(
    {
      url: `/api/teams/${teamId}/project-preferences`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateTeamProjectPreferencesBody,
    },
    options,
  );
};

export const getUpdateTeamProjectPreferencesMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamProjectPreferences>>,
    TError,
    { teamId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamProjectPreferences>>,
  TError,
  { teamId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["updateTeamProjectPreferences"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamProjectPreferences>>,
    { teamId: string; data: string[] }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return updateTeamProjectPreferences(teamId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamProjectPreferencesMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamProjectPreferences>>
>;
export type UpdateTeamProjectPreferencesMutationBody = string[];
export type UpdateTeamProjectPreferencesMutationError = PublicError;

export const useUpdateTeamProjectPreferences = <
  TError = PublicError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamProjectPreferences>>,
      TError,
      { teamId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamProjectPreferences>>,
  TError,
  { teamId: string; data: string[] },
  TContext
> => {
  const mutationOptions =
    getUpdateTeamProjectPreferencesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTeamRoles = (
  teamId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TeamRole[]>(
    { url: `/api/teams/${teamId}/roles`, method: "GET", signal },
    options,
  );
};

export const getGetTeamRolesQueryKey = (teamId: string) => {
  return [`/api/teams/${teamId}/roles`] as const;
};

export const getGetTeamRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamRoles>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTeamRolesQueryKey(teamId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeamRoles>>> = ({
    signal,
  }) => getTeamRoles(teamId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!teamId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamRoles>>
>;
export type GetTeamRolesQueryError = PublicError;

export function useGetTeamRoles<
  TData = Awaited<ReturnType<typeof getTeamRoles>>,
  TError = PublicError,
>(
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamRoles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamRoles>>,
          TError,
          Awaited<ReturnType<typeof getTeamRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamRoles<
  TData = Awaited<ReturnType<typeof getTeamRoles>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamRoles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamRoles>>,
          TError,
          Awaited<ReturnType<typeof getTeamRoles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamRoles<
  TData = Awaited<ReturnType<typeof getTeamRoles>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeamRoles<
  TData = Awaited<ReturnType<typeof getTeamRoles>>,
  TError = PublicError,
>(
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeamRoles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamRolesQueryOptions(teamId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const putTeamRoles = (
  teamId: string,
  putTeamRolesBody: PutTeamRolesBody,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AffectedRows>(
    {
      url: `/api/teams/${teamId}/roles`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: putTeamRolesBody,
    },
    options,
  );
};

export const getPutTeamRolesMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putTeamRoles>>,
    TError,
    { teamId: string; data: PutTeamRolesBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putTeamRoles>>,
  TError,
  { teamId: string; data: PutTeamRolesBody },
  TContext
> => {
  const mutationKey = ["putTeamRoles"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putTeamRoles>>,
    { teamId: string; data: PutTeamRolesBody }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return putTeamRoles(teamId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutTeamRolesMutationResult = NonNullable<
  Awaited<ReturnType<typeof putTeamRoles>>
>;
export type PutTeamRolesMutationBody = PutTeamRolesBody;
export type PutTeamRolesMutationError = PublicError;

export const usePutTeamRoles = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putTeamRoles>>,
      TError,
      { teamId: string; data: PutTeamRolesBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putTeamRoles>>,
  TError,
  { teamId: string; data: PutTeamRolesBody },
  TContext
> => {
  const mutationOptions = getPutTeamRolesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteTeamRoles = (
  teamId: string,
  deleteTeamRolesBody: DeleteTeamRolesBody,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AffectedRows>(
    {
      url: `/api/teams/${teamId}/roles`,
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      data: deleteTeamRolesBody,
    },
    options,
  );
};

export const getDeleteTeamRolesMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTeamRoles>>,
    TError,
    { teamId: string; data: DeleteTeamRolesBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTeamRoles>>,
  TError,
  { teamId: string; data: DeleteTeamRolesBody },
  TContext
> => {
  const mutationKey = ["deleteTeamRoles"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTeamRoles>>,
    { teamId: string; data: DeleteTeamRolesBody }
  > = (props) => {
    const { teamId, data } = props ?? {};

    return deleteTeamRoles(teamId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTeamRolesMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTeamRoles>>
>;
export type DeleteTeamRolesMutationBody = DeleteTeamRolesBody;
export type DeleteTeamRolesMutationError = PublicError;

export const useDeleteTeamRoles = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTeamRoles>>,
      TError,
      { teamId: string; data: DeleteTeamRolesBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTeamRoles>>,
  TError,
  { teamId: string; data: DeleteTeamRolesBody },
  TContext
> => {
  const mutationOptions = getDeleteTeamRolesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createUpload = (
  createUploadDTO: CreateUploadDTO,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UploadUrl>(
    {
      url: `/api/uploads`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createUploadDTO,
      signal,
    },
    options,
  );
};

export const getCreateUploadMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUpload>>,
    TError,
    { data: CreateUploadDTO },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUpload>>,
  TError,
  { data: CreateUploadDTO },
  TContext
> => {
  const mutationKey = ["createUpload"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUpload>>,
    { data: CreateUploadDTO }
  > = (props) => {
    const { data } = props ?? {};

    return createUpload(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUploadMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUpload>>
>;
export type CreateUploadMutationBody = CreateUploadDTO;
export type CreateUploadMutationError = PublicError;

export const useCreateUpload = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUpload>>,
      TError,
      { data: CreateUploadDTO },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUpload>>,
  TError,
  { data: CreateUploadDTO },
  TContext
> => {
  const mutationOptions = getCreateUploadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getMe = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<User>(
    { url: `/api/users/me`, method: "GET", signal },
    options,
  );
};

export const getGetMeQueryKey = () => {
  return [`/api/users/me`] as const;
};

export const getGetMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = PublicError,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({
    signal,
  }) => getMe(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>;
export type GetMeQueryError = PublicError;

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = PublicError,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = PublicError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateMe = (
  userForUpdate: UserForUpdate,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<User>(
    {
      url: `/api/users/me`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: userForUpdate,
    },
    options,
  );
};

export const getUpdateMeMutationOptions = <
  TError = PublicError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMe>>,
    TError,
    { data: UserForUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMe>>,
  TError,
  { data: UserForUpdate },
  TContext
> => {
  const mutationKey = ["updateMe"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMe>>,
    { data: UserForUpdate }
  > = (props) => {
    const { data } = props ?? {};

    return updateMe(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMe>>
>;
export type UpdateMeMutationBody = UserForUpdate;
export type UpdateMeMutationError = PublicError;

export const useUpdateMe = <TError = PublicError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMe>>,
      TError,
      { data: UserForUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateMe>>,
  TError,
  { data: UserForUpdate },
  TContext
> => {
  const mutationOptions = getUpdateMeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getMyPolicies = (
  params?: GetMyPoliciesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Policies>(
    { url: `/api/users/me/policies`, method: "GET", params, signal },
    options,
  );
};

export const getGetMyPoliciesQueryKey = (params?: GetMyPoliciesParams) => {
  return [`/api/users/me/policies`, ...(params ? [params] : [])] as const;
};

export const getGetMyPoliciesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyPolicies>>,
  TError = PublicError,
>(
  params?: GetMyPoliciesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyPolicies>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMyPoliciesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyPolicies>>> = ({
    signal,
  }) => getMyPolicies(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyPolicies>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyPoliciesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyPolicies>>
>;
export type GetMyPoliciesQueryError = PublicError;

export function useGetMyPolicies<
  TData = Awaited<ReturnType<typeof getMyPolicies>>,
  TError = PublicError,
>(
  params: undefined | GetMyPoliciesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyPolicies>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyPolicies>>,
          TError,
          Awaited<ReturnType<typeof getMyPolicies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyPolicies<
  TData = Awaited<ReturnType<typeof getMyPolicies>>,
  TError = PublicError,
>(
  params?: GetMyPoliciesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyPolicies>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyPolicies>>,
          TError,
          Awaited<ReturnType<typeof getMyPolicies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyPolicies<
  TData = Awaited<ReturnType<typeof getMyPolicies>>,
  TError = PublicError,
>(
  params?: GetMyPoliciesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyPolicies>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMyPolicies<
  TData = Awaited<ReturnType<typeof getMyPolicies>>,
  TError = PublicError,
>(
  params?: GetMyPoliciesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyPolicies>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMyPoliciesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
